// This file is fully generated by running parsergen v1.6.0
// with grammer definition file "grammar.txt"

// %HEADERS_FOR_CPP expanded BEGIN
#include "AST.h"        // All lex types for this parser
// %HEADERS_FOR_CPP expanded END
#include "Parser.h"
#include "ParserIdDef.h"
#include <bux/ImplGLR.h>
#include <bux/XException.h>

namespace {

using namespace bux::GLR;

//
//   Generated Constants
//
enum
{
    NID_expr      = TID_UB_+0,	// <expr>
    NID_id_list   = TID_UB_+1,	// <id_list>
    NID_type      = TID_UB_+2,	// <type>
    NID_type_decl = TID_UB_+3,	// <type_decl>
    TOKENGEN_UB,
    //---------------------------------------------------
    ENCODED_TOKEN_LB	 = 62
};
#define ZIP_TOKEN(x) (x-(bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB))

constinit const uint8_t
alphaPrime0[4] = {
    '(',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_expr),
    ZIP_TOKEN(NID_id_list)},
alphaPrime1[4] = {
    '(',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_expr),
    ZIP_TOKEN(NID_type)},
alphaPrime2[5] = {
    ')',
    '*',
    '+',
    '-',
    '/'},
alphaPrime3[2] = {
    ')',
    ','},
alphaPrime4[5] = {
    '*',
    '+',
    '-',
    '/',
    ';'},
alphaPrime5[5] = {
    '*',
    '+',
    '-',
    '/',
    ZIP_TOKEN(TID_LITERAL_2e2e)},
alphaPrime6[2] = {
    ZIP_TOKEN(TID_KEYWORD_type),
    ZIP_TOKEN(NID_type_decl)};

template<uint8_t KEY> int isKey(uint8_t key)
{
    return key == KEY? 0: -1;
}

int findKey(const uint8_t *klist, int n, uint8_t key)
{
    for (int i = 0; i < n; ++i)
         if (key == klist[i])
             return i;
    return -1;
}

int findPrime0_0_2	(uint8_t key)	{ return findKey(alphaPrime0,2,key); }
int findPrime0_0_3	(uint8_t key)	{ return findKey(alphaPrime0,3,key); }
int findPrime0_0_4	(uint8_t key)	{ return findKey(alphaPrime0,4,key); }
int findPrime1_0_4	(uint8_t key)	{ return findKey(alphaPrime1,4,key); }
int findPrime2_0_5	(uint8_t key)	{ return findKey(alphaPrime2,5,key); }
int findPrime2_1_4	(uint8_t key)	{ return findKey(alphaPrime2+1,4,key); }
int findPrime3_0_2	(uint8_t key)	{ return findKey(alphaPrime3,2,key); }
int findPrime4_0_5	(uint8_t key)	{ return findKey(alphaPrime4,5,key); }
int findPrime5_0_5	(uint8_t key)	{ return findKey(alphaPrime5,5,key); }
int findPrime6_0_2	(uint8_t key)	{ return findKey(alphaPrime6,2,key); }

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2A_Table0[] ={
    {')',	ACTION_REDUCE_MIN + 6},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 6},
    {'-',	ACTION_REDUCE_MIN + 6},
    {'/',	ACTION_SHIFT}},
L2A_Table1[] ={
    {')',	ACTION_REDUCE_MIN + 7},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 7},
    {'-',	ACTION_REDUCE_MIN + 7},
    {'/',	ACTION_SHIFT}},
L2A_Table2[] ={
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 6},
    {'-',	ACTION_REDUCE_MIN + 6},
    {'/',	ACTION_SHIFT},
    {';',	ACTION_REDUCE_MIN + 6}},
L2A_Table3[] ={
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 6},
    {'-',	ACTION_REDUCE_MIN + 6},
    {'/',	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_2e2e),	ACTION_REDUCE_MIN + 6}},
L2A_Table4[] ={
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 7},
    {'-',	ACTION_REDUCE_MIN + 7},
    {'/',	ACTION_SHIFT},
    {';',	ACTION_REDUCE_MIN + 7}},
L2A_Table5[] ={
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_REDUCE_MIN + 7},
    {'-',	ACTION_REDUCE_MIN + 7},
    {'/',	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_2e2e),	ACTION_REDUCE_MIN + 7}},
L2A_Table6[] ={
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'-',	ACTION_SHIFT},
    {'/',	ACTION_SHIFT},
    {';',	ACTION_REDUCE_MIN + 2}},
L2A_Table7[] ={
    {')',	ACTION_REDUCE_MIN + 3},
    {')',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_REDUCE_MIN + 10},
    {'+',	ACTION_REDUCE_MIN + 10},
    {',',	ACTION_REDUCE_MIN + 3},
    {'-',	ACTION_REDUCE_MIN + 10},
    {'/',	ACTION_REDUCE_MIN + 10}};

constinit const bux::U_K2V<uint8_t,uint8_t> mapActionPtr[52] ={
    isKey<ZIP_TOKEN(TID_KEYWORD_type)>,	// 0
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 1
    isKey<ZIP_TOKEN(bux::TID_EOF)>,	// 2
    isKey<'='>,	// 3
    findPrime0_0_2,	// 4
    findPrime0_0_2,	// 5
    findPrime5_0_5,	// 6
    findPrime5_0_5,	// 7
    isKey<';'>,	// 8
    findPrime0_0_2,	// 9
    L2A_Table7,	// 10
    findPrime2_0_5,	// 11
    findPrime3_0_2,	// 12
    findPrime0_0_2,	// 13
    findPrime0_0_2,	// 14
    findPrime0_0_2,	// 15
    findPrime0_0_2,	// 16
    findPrime0_0_2,	// 17
    isKey<ZIP_TOKEN(bux::TID_EOF)>,	// 18
    findPrime2_0_5,	// 19
    findPrime2_0_5,	// 20
    findPrime5_0_5,	// 21
    findPrime0_0_2,	// 22
    findPrime0_0_2,	// 23
    findPrime0_0_2,	// 24
    findPrime0_0_2,	// 25
    isKey<';'>,	// 26
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 27
    findPrime0_0_2,	// 28
    findPrime5_0_5,	// 29
    L2A_Table3,	// 30
    L2A_Table5,	// 31
    findPrime5_0_5,	// 32
    findPrime0_0_2,	// 33
    findPrime4_0_5,	// 34
    L2A_Table6,	// 35
    findPrime2_0_5,	// 36
    findPrime2_0_5,	// 37
    L2A_Table0,	// 38
    L2A_Table1,	// 39
    findPrime2_0_5,	// 40
    findPrime3_0_2,	// 41
    findPrime2_0_5,	// 42
    findPrime0_0_2,	// 43
    findPrime0_0_2,	// 44
    findPrime0_0_2,	// 45
    findPrime0_0_2,	// 46
    findPrime4_0_5,	// 47
    findPrime4_0_5,	// 48
    L2A_Table2,	// 49
    L2A_Table4,	// 50
    findPrime4_0_5};	// 51

constinit const int8_t mapActionSizeEx[52] ={
    ACTION_SHIFT,	// 0
    ACTION_SHIFT,	// 1
    ACTION_ACCEPT,	// 2
    ACTION_SHIFT,	// 3
    ACTION_SHIFT,	// 4
    ACTION_SHIFT,	// 5
    ACTION_REDUCE_MIN + 10,	// 6
    ACTION_SHIFT,	// 7
    ACTION_SHIFT,	// 8
    ACTION_SHIFT,	// 9
    -7,	// 10
    ACTION_SHIFT,	// 11
    ACTION_SHIFT,	// 12
    ACTION_SHIFT,	// 13
    ACTION_SHIFT,	// 14
    ACTION_SHIFT,	// 15
    ACTION_SHIFT,	// 16
    ACTION_SHIFT,	// 17
    ACTION_REDUCE_MIN + 0,	// 18
    ACTION_REDUCE_MIN + 10,	// 19
    ACTION_SHIFT,	// 20
    ACTION_REDUCE_MIN + 5,	// 21
    ACTION_SHIFT,	// 22
    ACTION_SHIFT,	// 23
    ACTION_SHIFT,	// 24
    ACTION_SHIFT,	// 25
    ACTION_REDUCE_MIN + 1,	// 26
    ACTION_SHIFT,	// 27
    ACTION_SHIFT,	// 28
    ACTION_REDUCE_MIN + 8,	// 29
    -5,	// 30
    -5,	// 31
    ACTION_REDUCE_MIN + 9,	// 32
    ACTION_SHIFT,	// 33
    ACTION_REDUCE_MIN + 10,	// 34
    -5,	// 35
    ACTION_REDUCE_MIN + 5,	// 36
    ACTION_REDUCE_MIN + 8,	// 37
    -5,	// 38
    -5,	// 39
    ACTION_REDUCE_MIN + 9,	// 40
    ACTION_REDUCE_MIN + 4,	// 41
    ACTION_SHIFT,	// 42
    ACTION_SHIFT,	// 43
    ACTION_SHIFT,	// 44
    ACTION_SHIFT,	// 45
    ACTION_SHIFT,	// 46
    ACTION_REDUCE_MIN + 5,	// 47
    ACTION_REDUCE_MIN + 8,	// 48
    -5,	// 49
    -5,	// 50
    ACTION_REDUCE_MIN + 9};	// 51

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2S_Table0[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	11}},
L2S_Table1[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	20}},
L2S_Table2[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	37}},
L2S_Table3[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	38}},
L2S_Table4[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	39}},
L2S_Table5[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	40}},
L2S_Table6[] ={
    {'(',	9},
    {ZIP_TOKEN(TID_LEX_Id),	19},
    {ZIP_TOKEN(NID_expr),	42}},
L2S_Table7[] ={
    {'(',	28},
    {ZIP_TOKEN(TID_LEX_Id),	6},
    {ZIP_TOKEN(NID_expr),	29}},
L2S_Table8[] ={
    {'(',	28},
    {ZIP_TOKEN(TID_LEX_Id),	6},
    {ZIP_TOKEN(NID_expr),	30}},
L2S_Table9[] ={
    {'(',	28},
    {ZIP_TOKEN(TID_LEX_Id),	6},
    {ZIP_TOKEN(NID_expr),	31}},
L2S_Table10[] ={
    {'(',	28},
    {ZIP_TOKEN(TID_LEX_Id),	6},
    {ZIP_TOKEN(NID_expr),	32}},
L2S_Table11[] ={
    {'(',	33},
    {ZIP_TOKEN(TID_LEX_Id),	34},
    {ZIP_TOKEN(NID_expr),	48}},
L2S_Table12[] ={
    {'(',	33},
    {ZIP_TOKEN(TID_LEX_Id),	34},
    {ZIP_TOKEN(NID_expr),	49}},
L2S_Table13[] ={
    {'(',	33},
    {ZIP_TOKEN(TID_LEX_Id),	34},
    {ZIP_TOKEN(NID_expr),	50}},
L2S_Table14[] ={
    {'(',	33},
    {ZIP_TOKEN(TID_LEX_Id),	34},
    {ZIP_TOKEN(NID_expr),	51}},
L2S_Table15[] ={
    {')',	36},
    {'*',	22},
    {'+',	23},
    {'-',	24},
    {'/',	25}},
L2S_Table16[] ={
    {')',	47},
    {'*',	22},
    {'+',	23},
    {'-',	24},
    {'/',	25}},
L2S_Table17[] ={
    {'*',	13},
    {'/',	16}},
L2S_Table18[] ={
    {'*',	22},
    {'/',	25}},
L2S_Table19[] ={
    {'*',	43},
    {'/',	46}};

constinit const struct C_MapGoto {
    bux::U_K2V<uint8_t,uint8_t> m_k2v;
    uint8_t	m_curState;
    int8_t	m_nextStateEx;
}   mapGoto[35] ={
    {findPrime6_0_2,	0,	1},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	1,	3},
    {isKey<'='>,	3,	4},
    {findPrime1_0_4,	4,	5},
    {findPrime0_0_4,	5,	9},
    {findPrime5_0_5,	7,	13},
    {isKey<';'>,	8,	18},
    {L2S_Table1,	9,	-3},
    {findPrime2_0_5,	11,	21},
    {findPrime3_0_2,	12,	26},
    {L2S_Table7,	13,	-3},
    {L2S_Table8,	14,	-3},
    {L2S_Table9,	15,	-3},
    {L2S_Table10,	16,	-3},
    {findPrime0_0_3,	17,	33},
    {L2S_Table15,	20,	-5},
    {L2S_Table2,	22,	-3},
    {L2S_Table3,	23,	-3},
    {L2S_Table4,	24,	-3},
    {L2S_Table5,	25,	-3},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	27,	41},
    {L2S_Table0,	28,	-3},
    {L2S_Table17,	30,	-2},
    {L2S_Table17,	31,	-2},
    {L2S_Table6,	33,	-3},
    {findPrime2_1_4,	35,	43},
    {L2S_Table18,	38,	-2},
    {L2S_Table18,	39,	-2},
    {L2S_Table16,	42,	-5},
    {L2S_Table11,	43,	-3},
    {L2S_Table12,	44,	-3},
    {L2S_Table13,	45,	-3},
    {L2S_Table14,	46,	-3},
    {L2S_Table19,	49,	-2},
    {L2S_Table19,	50,	-2}};

void _reduce_0(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <type_decl> ::= type $Id = <type> ;
{
    _reT_ = new C_TypeDecl{bux::unlex<std::string>(_geT_(1)), _geT_(3)};
}

void _reduce_1(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <type> ::= ( <id_list> )
{
    _reT_ = _geT_(1);
}

void _reduce_2(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <type> ::= <expr> .. <expr>
{
    _reT_ = new C_BinaryOp{"..", _geT_(0), _geT_(2)};
}

void _reduce_3(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <id_list> ::= $Id
{
    _reT_ = bux::createLex<C_IdList>({bux::unlex<std::string>(_geT_(0))});
}

void _reduce_4(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <id_list> ::= <id_list> , $Id
{
    auto t{bux::unlex<C_IdList>(_geT_(0))};
    t.emplace_back(bux::unlex<std::string>(_geT_(2)));
    _reT_ = bux::createLex<C_IdList>(t);
}

void _reduce_5(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= ( <expr> )
{
    _reT_ = bux::createLex<C_LexPtr>(_geT_(1));
}

void _reduce_6(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= <expr> + <expr>
{
    _reT_ = new C_BinaryOp{"+", _geT_(0), _geT_(2)};
}

void _reduce_7(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= <expr> - <expr>
{
    _reT_ = new C_BinaryOp{"-", _geT_(0), _geT_(2)};
}

void _reduce_8(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= <expr> * <expr>
{
    _reT_ = new C_BinaryOp{"*", _geT_(0), _geT_(2)};
}

void _reduce_9(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= <expr> / <expr>
{
    _reT_ = new C_BinaryOp{"/", _geT_(0), _geT_(2)};
}

void _reduce_10(bux::GLR::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_, F_OncePostShift &)
//  <expr> ::= $Id
//  <@> ::= <type_decl>
{
    _reT_ = _geT_(0);
}

struct C_ProductionInfo
{
    void            (*m_pAction)(bux::GLR::C_Parser&,const F_GetProduced&,C_RetLval,F_OncePostShift&);
    uint8_t         m_ReducedID;
    uint8_t         m_PopLength;
} constinit const prodInfo[12] ={
{_reduce_0, 	ZIP_TOKEN(NID_type_decl), 5},	// 0: <type_decl> ::= type $Id = <type> ;
{_reduce_1, 	ZIP_TOKEN(NID_type), 3},	// 1: <type> ::= ( <id_list> )
{_reduce_2, 	ZIP_TOKEN(NID_type), 3},	// 2: <type> ::= <expr> .. <expr>
{_reduce_3, 	ZIP_TOKEN(NID_id_list), 1},	// 3: <id_list> ::= $Id
{_reduce_4, 	ZIP_TOKEN(NID_id_list), 3},	// 4: <id_list> ::= <id_list> , $Id
{_reduce_5, 	ZIP_TOKEN(NID_expr), 3},	// 5: <expr> ::= ( <expr> )
{_reduce_6, 	ZIP_TOKEN(NID_expr), 3},	// 6: <expr> ::= <expr> + <expr>
{_reduce_7, 	ZIP_TOKEN(NID_expr), 3},	// 7: <expr> ::= <expr> - <expr>
{_reduce_8, 	ZIP_TOKEN(NID_expr), 3},	// 8: <expr> ::= <expr> * <expr>
{_reduce_9, 	ZIP_TOKEN(NID_expr), 3},	// 9: <expr> ::= <expr> / <expr>
{_reduce_10,	ZIP_TOKEN(NID_expr), 1},	// 10: <expr> ::= $Id
{_reduce_10,	ZIP_TOKEN(bux::ROOT_NID), 1} 	// 11: <@> ::= <type_decl>
};

struct C_ActionTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&) { return static_cast<uint8_t>(t1); }
};

struct C_ShiftTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&t2) { return static_cast<uint8_t>(t1+t2); }
    static uint8_t valueError() { RUNTIME_ERROR("SHIFT ERROR"); }
};

//
//   Generated Parser Policy
//
class C_ParserPolicy: public I_ParserPolicy
{
public:

    // Implement I_ParserPolicy
    std::vector<T_ActionId> action(bux::T_StateID state, bux::T_LexID token) const override;
    size_t getAcceptId() const override;
    bool getTokenName(bux::T_LexID token, std::string &name) const override;
    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;
    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;
    void onError(bux::GLR::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, const std::string &message) const override;
}   g_policy;

std::vector<T_ActionId> C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        return {};

    auto t = index2values<uint8_t,uint8_t,int8_t,C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);
    return {t.begin(), t.end()};
}

size_t C_ParserPolicy::getAcceptId() const
{
    return 11;
}

bool C_ParserPolicy::getTokenName(bux::T_LexID token, std::string &name) const
{
    static constinit char const *const NAMES[8] = {
        "$Id",
        "$Spaces",
        "\"type\"",
        "\"..\"",
        "<expr>",
        "<id_list>",
        "<type>",
        "<type_decl>"};
    if (bux::TOKENGEN_LB <= token && token < bux::TOKENGEN_LB + 8)
    {
        name = NAMES[token - bux::TOKENGEN_LB];
        return true;
    }
    return false;
}

bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        LOGIC_ERROR("Invalid input: state={} input={}", (int)state, printToken(input));

    auto end = mapGoto + 35;
    auto found = std::lower_bound(mapGoto, end, state, [](const C_MapGoto &i, bux::T_StateID state_) {
        return i.m_curState < state_;
    });
    if (found != end && found->m_curState == state)
        return index2value<uint8_t,uint8_t,int8_t,C_ShiftTraits>(found->m_k2v, found->m_nextStateEx, input);

    RUNTIME_ERROR("Invalid state: state={} input={}", (int)state, printToken(input));
}

void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const
{
    const auto &src  = prodInfo[id];
    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB);
    info.m_PopLength = src.m_PopLength;
    info.m_Reduce    = src.m_pAction;
}

void C_ParserPolicy::onError(bux::GLR::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, const std::string &message) const
{
    // User-defined %ON_ERROR begins
    *static_cast<::C_Parser::C_Context*>(_paRSeR_.userData()) <<"COL#" <<pos.m_Col <<": " <<message <<'\n';
    // User-defined %ON_ERROR ends
}

} // namespace

::C_Parser::C_Parser(): bux::GLR::C_Parser(g_policy) {}
