// This file is fully generated by running parsergen v1.7.5
// with grammer definition file "grammar.txt"

// Grammar %HEADERS_FOR_CPP undefined (expanded here otherwise)
#include "Parser.h"
#include "ParserIdDef.h"
#include <bux/ImplLR1.h>
#include <bux/XException.h>

namespace {

using namespace bux::LR1;
// Grammar %LOCAL_CPP undefined (expanded here otherwise)

//
//   Generated Constants
//
enum
{
    ENCODED_TOKEN_LB	 = 1
};
constexpr auto ZIP_TOKEN(auto x) { return x-(bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB); }

template<uint8_t KEY> int isKey(uint8_t key)
{
    return key == KEY? 0: -1;
}

constinit const bux::U_K2V<uint8_t,uint8_t> mapActionPtr[1] ={
    isKey<ZIP_TOKEN(bux::TID_EOF)>};	// 0

constinit const int8_t mapActionSizeEx[1] ={
    ACTION_ACCEPT};	// 0

struct C_ProductionInfo
{
    void            (*m_pAction)(bux::LR1::C_Parser&,const F_GetProduced&,C_RetLval);
    uint8_t         m_ReducedID;
    uint8_t         m_PopLength;
} constinit const prodInfo[1] ={
{nullptr,    	ZIP_TOKEN(bux::ROOT_NID), 0} 	// 0: <@> ::=
};

struct C_ActionTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&) { return static_cast<uint8_t>(t1); }
    static uint8_t valueError() { return ACTION_ERROR; }
};

//
//   Generated Parser Policy
//
class C_ParserPolicy: public I_ParserPolicy
{
public:

    // Ctor
    C_ParserPolicy(): I_ParserPolicy(TOKENGEN_UB+2) {}

    // Implement I_ParserPolicy
    size_t action(bux::T_StateID state, bux::T_LexID token) const override;
    size_t getAcceptId() const override;
    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;
    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;
    void onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, std::string_view message) const override;
}   g_policy;

size_t C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        return ACTION_ERROR;

    return index2value<uint8_t,uint8_t,int8_t,C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);
}

size_t C_ParserPolicy::getAcceptId() const
{
    return 0;
}

bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const
{
    // Empty mapGoto[]
    RUNTIME_ERROR("Invalid state: state={} input={}", (int)state, printToken(input));
}

void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const
{
    const auto &src  = prodInfo[id];
    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB);
    info.m_PopLength = src.m_PopLength;
    info.m_Reduce    = src.m_pAction;
}

void C_ParserPolicy::onError(bux::LR1::C_Parser &, const bux::C_SourcePos &pos, std::string_view message) const
{
    RUNTIME_ERROR("{}@({},{}): {}", pos.m_Source, pos.m_Line, pos.m_Col, message);
}

} // namespace
// Grammar %SCOPED_CPP_HEAD undefined (expanded here otherwise)

::C_Parser::C_Parser(): bux::LR1::C_Parser(g_policy) {}
// Grammar %SCOPED_CPP_TAIL undefined (expanded here otherwise)
