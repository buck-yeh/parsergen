// This file is fully generated by running parsergen v1.6.2
// with grammer definition file "grammar.txt"

// Grammar %HEADERS_FOR_CPP begins
#include "spec2charset.h"   // spec2charset()
#include <bux/LexBase.h>    // bux::T_LexID
#include <bux/LogStream.h>  // HRTN()

void parseFile(const std::string &filename, class C_ScannerParser &parser, bux::T_LexID endToken);
// Grammar %HEADERS_FOR_CPP ends
#include "Parser.h"
#include "ParserIdDef.h"
#include <bux/ImplLR1.h>
#include <bux/XException.h>

namespace {

using namespace bux::LR1;
// Grammar %LOCAL_CPP begins
using namespace bux;

//
//      In-Module Types
//
typedef bux::C_Stack<bux::T_LexID> C_IdStack;

struct C_LexListLex: bux::I_LexAttr
{
    // Data
    C_IdStack list;

    // Nonvirtuals
    C_LexListLex()
        {}
    template<class T_Iter>
    C_LexListLex(T_Iter beg, T_Iter end)
        { list.push(beg, end); }
};
// Grammar %LOCAL_CPP ends

//
//   Generated Constants
//
enum
{
    NID_All           = TID_UB_+0,	// <All>
    NID_BW_List       = TID_UB_+1,	// <BW_List>
    NID_Integer       = TID_UB_+2,	// <Integer>
    NID_LexExpr       = TID_UB_+3,	// <LexExpr>
    NID_LexResult     = TID_UB_+4,	// <LexResult>
    NID_LexTerm       = TID_UB_+5,	// <LexTerm>
    NID_Line          = TID_UB_+6,	// <Line>
    NID_OptionValue   = TID_UB_+7,	// <OptionValue>
    NID_RegExpr       = TID_UB_+8,	// <RegExpr>
    NID_RegExprSeq    = TID_UB_+9,	// <RegExprSeq>
    NID_RegExprTerm   = TID_UB_+10,	// <RegExprTerm>
    NID_SubCharSet    = TID_UB_+11,	// <SubCharSet>
    NID_WithFinalCond = TID_UB_+12,	// <WithFinalCond>
    NIDa_keyword      = TID_UB_+13,	// <@keyword>
    NIDa_operator     = TID_UB_+14,	// <@operator>
    TOKENGEN_UB,
    //---------------------------------------------------
    ENCODED_TOKEN_LB	 = 126
};
constexpr auto ZIP_TOKEN(auto x) { return x-(bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB); }

constinit const uint8_t
alphaPrime0[13] = {
    '\n',
    '(',
    '*',
    '+',
    '[',
    '{',
    '|',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime1[10] = {
    '\n',
    '@',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime2[9] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime3[3] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_KEYWORD_if)},
alphaPrime4[5] = {
    '#',
    '%',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_All),
    ZIP_TOKEN(NID_Line)},
alphaPrime5[11] = {
    '(',
    ')',
    '*',
    '+',
    '[',
    '{',
    '|',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String)},
alphaPrime6[11] = {
    '(',
    '*',
    '+',
    '[',
    '{',
    '|',
    '}',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String)},
alphaPrime7[9] = {
    '(',
    '[',
    '{',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(NID_RegExpr),
    ZIP_TOKEN(NID_RegExprSeq),
    ZIP_TOKEN(NID_RegExprTerm)},
alphaPrime8[2] = {
    ')',
    '|'},
alphaPrime9[3] = {
    '*',
    '+',
    ZIP_TOKEN(TID_LEX_Num)},
alphaPrime10[5] = {
    '+',
    '-',
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(NID_Integer)},
alphaPrime11[2] = {
    ',',
    ']'},
alphaPrime12[8] = {
    '^',
    ZIP_TOKEN(TID_LEX_Charset),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(NID_BW_List),
    ZIP_TOKEN(NID_SubCharSet)},
alphaPrime13[3] = {
    '|',
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexResult)},
alphaPrime14[13] = {
    ZIP_TOKEN(TID_LEX_Bracketed),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexExpr),
    ZIP_TOKEN(NID_LexTerm),
    ZIP_TOKEN(NID_OptionValue),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)},
alphaPrime15[11] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexExpr),
    ZIP_TOKEN(NID_LexTerm),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)};

template<uint8_t KEY> int isKey(uint8_t key)
{
    return key == KEY? 0: -1;
}

int findKey(const uint8_t *klist, int n, uint8_t key)
{
    for (int i = 0; i < n; ++i)
         if (key == klist[i])
             return i;
    return -1;
}

int findPrime0_0_13	(uint8_t key)	{ return findKey(alphaPrime0,13,key); }
int findPrime10_0_4	(uint8_t key)	{ return findKey(alphaPrime10,4,key); }
int findPrime10_0_5	(uint8_t key)	{ return findKey(alphaPrime10,5,key); }
int findPrime11_0_2	(uint8_t key)	{ return findKey(alphaPrime11,2,key); }
int findPrime12_0_8	(uint8_t key)	{ return findKey(alphaPrime12,8,key); }
int findPrime12_1_5	(uint8_t key)	{ return findKey(alphaPrime12+1,5,key); }
int findPrime13_0_3	(uint8_t key)	{ return findKey(alphaPrime13,3,key); }
int findPrime14_0_13	(uint8_t key)	{ return findKey(alphaPrime14,13,key); }
int findPrime14_0_8	(uint8_t key)	{ return findKey(alphaPrime14,8,key); }
int findPrime15_0_11	(uint8_t key)	{ return findKey(alphaPrime15,11,key); }
int findPrime1_0_10	(uint8_t key)	{ return findKey(alphaPrime1,10,key); }
int findPrime1_3_7	(uint8_t key)	{ return findKey(alphaPrime1+3,7,key); }
int findPrime2_0_2	(uint8_t key)	{ return findKey(alphaPrime2,2,key); }
int findPrime2_0_9	(uint8_t key)	{ return findKey(alphaPrime2,9,key); }
int findPrime3_0_3	(uint8_t key)	{ return findKey(alphaPrime3,3,key); }
int findPrime4_0_5	(uint8_t key)	{ return findKey(alphaPrime4,5,key); }
int findPrime5_0_11	(uint8_t key)	{ return findKey(alphaPrime5,11,key); }
int findPrime6_0_11	(uint8_t key)	{ return findKey(alphaPrime6,11,key); }
int findPrime6_5_2	(uint8_t key)	{ return findKey(alphaPrime6+5,2,key); }
int findPrime7_0_6	(uint8_t key)	{ return findKey(alphaPrime7,6,key); }
int findPrime7_0_9	(uint8_t key)	{ return findKey(alphaPrime7,9,key); }
int findPrime8_0_2	(uint8_t key)	{ return findKey(alphaPrime8,2,key); }
int findPrime9_0_3	(uint8_t key)	{ return findKey(alphaPrime9,3,key); }

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2A_Table0[] ={
    {'\n',	ACTION_REDUCE_MIN + 2},
    {'#',	ACTION_SHIFT},
    {'%',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 2},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT}},
L2A_Table1[] ={
    {'\n',	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table2[] ={
    {'\n',	ACTION_REDUCE_MIN + 8},
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 8}},
L2A_Table3[] ={
    {'\n',	ACTION_REDUCE_MIN + 9},
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 9}},
L2A_Table4[] ={
    {'\n',	ACTION_REDUCE_MIN + 10},
    {'(',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 10}},
L2A_Table5[] ={
    {'\n',	ACTION_REDUCE_MIN + 11},
    {'(',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 11}},
L2A_Table6[] ={
    {'\n',	ACTION_REDUCE_MIN + 32},
    {'|',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 32},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table7[] ={
    {'\n',	ACTION_REDUCE_MIN + 34},
    {'@',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 34},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table8[] ={
    {'\n',	ACTION_REDUCE_MIN + 35},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 35},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT}},
L2A_Table9[] ={
    {'\n',	ACTION_REDUCE_MIN + 36},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 36},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table10[] ={
    {'\n',	ACTION_REDUCE_MIN + 37},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 37},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table11[] ={
    {'\n',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_ACCEPT}},
L2A_Table12[] ={
    {'(',	ACTION_REDUCE_MIN + 10},
    {')',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10}},
L2A_Table13[] ={
    {'(',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {'}',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10}},
L2A_Table14[] ={
    {'(',	ACTION_REDUCE_MIN + 11},
    {')',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11}},
L2A_Table15[] ={
    {'(',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {'}',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11}},
L2A_Table16[] ={
    {'(',	ACTION_SHIFT},
    {')',	ACTION_REDUCE_MIN + 8},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table17[] ={
    {'(',	ACTION_SHIFT},
    {')',	ACTION_REDUCE_MIN + 9},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table18[] ={
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {'}',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table19[] ={
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {'}',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table20[] ={
    {']',	ACTION_REDUCE_MIN + 21},
    {'^',	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Charset),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table21[] ={
    {']',	ACTION_REDUCE_MIN + 22},
    {ZIP_TOKEN(TID_LEX_Charset),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table22[] ={
    {',',	ACTION_REDUCE_MIN + 29},
    {'-',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 29}},
L2A_Table23[] ={
    {',',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 23}},
L2A_Table24[] ={
    {',',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 24}};

constinit const bux::U_K2V<uint8_t,uint8_t> mapActionPtr[125] ={
    L2A_Table0,	// 0
    isKey<ZIP_TOKEN(TID_KEYWORD_include)>,	// 1
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 2
    isKey<'='>,	// 3
    L2A_Table11,	// 4
    findPrime2_0_2,	// 5
    isKey<ZIP_TOKEN(TID_LEX_String)>,	// 6
    findPrime14_0_8,	// 7
    findPrime7_0_6,	// 8
    L2A_Table0,	// 9
    findPrime2_0_2,	// 10
    findPrime2_0_2,	// 11
    findPrime2_0_9,	// 12
    findPrime2_0_9,	// 13
    findPrime2_0_9,	// 14
    findPrime2_0_9,	// 15
    findPrime2_0_9,	// 16
    findPrime2_0_9,	// 17
    findPrime2_0_9,	// 18
    L2A_Table1,	// 19
    findPrime2_0_9,	// 20
    findPrime2_0_2,	// 21
    findPrime2_0_9,	// 22
    findPrime2_0_9,	// 23
    findPrime7_0_6,	// 24
    L2A_Table20,	// 25
    findPrime7_0_6,	// 26
    findPrime0_0_13,	// 27
    findPrime0_0_13,	// 28
    findPrime0_0_13,	// 29
    L2A_Table6,	// 30
    L2A_Table2,	// 31
    L2A_Table4,	// 32
    findPrime2_0_2,	// 33
    findPrime2_0_9,	// 34
    findPrime7_0_6,	// 35
    L2A_Table20,	// 36
    findPrime7_0_6,	// 37
    findPrime5_0_11,	// 38
    findPrime5_0_11,	// 39
    findPrime5_0_11,	// 40
    findPrime8_0_2,	// 41
    L2A_Table16,	// 42
    L2A_Table12,	// 43
    L2A_Table21,	// 44
    findPrime11_0_2,	// 45
    findPrime11_0_2,	// 46
    L2A_Table22,	// 47
    findPrime11_0_2,	// 48
    findPrime11_0_2,	// 49
    isKey<']'>,	// 50
    L2A_Table23,	// 51
    findPrime7_0_6,	// 52
    L2A_Table20,	// 53
    findPrime7_0_6,	// 54
    findPrime6_0_11,	// 55
    findPrime6_0_11,	// 56
    findPrime6_0_11,	// 57
    findPrime6_5_2,	// 58
    L2A_Table18,	// 59
    L2A_Table13,	// 60
    findPrime7_0_6,	// 61
    findPrime1_3_7,	// 62
    findPrime2_0_2,	// 63
    L2A_Table5,	// 64
    findPrime0_0_13,	// 65
    findPrime0_0_13,	// 66
    findPrime0_0_13,	// 67
    findPrime8_0_2,	// 68
    isKey<']'>,	// 69
    findPrime6_5_2,	// 70
    findPrime0_0_13,	// 71
    findPrime7_0_6,	// 72
    L2A_Table14,	// 73
    findPrime5_0_11,	// 74
    findPrime5_0_11,	// 75
    findPrime5_0_11,	// 76
    L2A_Table24,	// 77
    isKey<ZIP_TOKEN(TID_LEX_Key)>,	// 78
    findPrime0_0_13,	// 79
    findPrime12_1_5,	// 80
    findPrime8_0_2,	// 81
    isKey<']'>,	// 82
    findPrime6_5_2,	// 83
    findPrime7_0_6,	// 84
    findPrime0_0_13,	// 85
    L2A_Table15,	// 86
    findPrime6_0_11,	// 87
    findPrime6_0_11,	// 88
    findPrime6_0_11,	// 89
    L2A_Table3,	// 90
    findPrime1_0_10,	// 91
    findPrime1_0_10,	// 92
    findPrime1_0_10,	// 93
    findPrime1_0_10,	// 94
    findPrime1_0_10,	// 95
    findPrime1_0_10,	// 96
    findPrime1_0_10,	// 97
    L2A_Table7,	// 98
    findPrime1_0_10,	// 99
    findPrime1_0_10,	// 100
    findPrime1_0_10,	// 101
    findPrime5_0_11,	// 102
    findPrime5_0_11,	// 103
    findPrime5_0_11,	// 104
    L2A_Table17,	// 105
    findPrime11_0_2,	// 106
    findPrime11_0_2,	// 107
    findPrime6_0_11,	// 108
    findPrime6_0_11,	// 109
    findPrime6_0_11,	// 110
    L2A_Table19,	// 111
    findPrime10_0_4,	// 112
    findPrime1_0_10,	// 113
    findPrime2_0_2,	// 114
    isKey<ZIP_TOKEN(TID_LEX_Num)>,	// 115
    isKey<ZIP_TOKEN(TID_LEX_Num)>,	// 116
    findPrime3_0_3,	// 117
    findPrime1_3_7,	// 118
    L2A_Table8,	// 119
    findPrime3_0_3,	// 120
    findPrime3_0_3,	// 121
    L2A_Table9,	// 122
    findPrime1_3_7,	// 123
    L2A_Table10};	// 124

constinit const int8_t mapActionSizeEx[125] ={
    -5,	// 0
    ACTION_SHIFT,	// 1
    ACTION_SHIFT,	// 2
    ACTION_SHIFT,	// 3
    -2,	// 4
    ACTION_REDUCE_MIN + 0,	// 5
    ACTION_SHIFT,	// 6
    ACTION_SHIFT,	// 7
    ACTION_SHIFT,	// 8
    -5,	// 9
    ACTION_REDUCE_MIN + 3,	// 10
    ACTION_REDUCE_MIN + 6,	// 11
    ACTION_REDUCE_MIN + 45,	// 12
    ACTION_REDUCE_MIN + 48,	// 13
    ACTION_REDUCE_MIN + 47,	// 14
    ACTION_REDUCE_MIN + 43,	// 15
    ACTION_REDUCE_MIN + 51,	// 16
    ACTION_REDUCE_MIN + 52,	// 17
    ACTION_REDUCE_MIN + 50,	// 18
    -9,	// 19
    ACTION_REDUCE_MIN + 41,	// 20
    ACTION_REDUCE_MIN + 4,	// 21
    ACTION_REDUCE_MIN + 46,	// 22
    ACTION_REDUCE_MIN + 44,	// 23
    ACTION_SHIFT,	// 24
    -7,	// 25
    ACTION_SHIFT,	// 26
    ACTION_REDUCE_MIN + 14,	// 27
    ACTION_REDUCE_MIN + 16,	// 28
    ACTION_REDUCE_MIN + 15,	// 29
    -4,	// 30
    -10,	// 31
    -13,	// 32
    ACTION_REDUCE_MIN + 1,	// 33
    ACTION_REDUCE_MIN + 42,	// 34
    ACTION_SHIFT,	// 35
    -7,	// 36
    ACTION_SHIFT,	// 37
    ACTION_REDUCE_MIN + 14,	// 38
    ACTION_REDUCE_MIN + 16,	// 39
    ACTION_REDUCE_MIN + 15,	// 40
    ACTION_SHIFT,	// 41
    -8,	// 42
    -11,	// 43
    -6,	// 44
    ACTION_REDUCE_MIN + 31,	// 45
    ACTION_REDUCE_MIN + 27,	// 46
    -3,	// 47
    ACTION_REDUCE_MIN + 28,	// 48
    ACTION_REDUCE_MIN + 26,	// 49
    ACTION_SHIFT,	// 50
    -2,	// 51
    ACTION_SHIFT,	// 52
    -7,	// 53
    ACTION_SHIFT,	// 54
    ACTION_REDUCE_MIN + 14,	// 55
    ACTION_REDUCE_MIN + 16,	// 56
    ACTION_REDUCE_MIN + 15,	// 57
    ACTION_SHIFT,	// 58
    -8,	// 59
    -11,	// 60
    ACTION_SHIFT,	// 61
    ACTION_SHIFT,	// 62
    ACTION_REDUCE_MIN + 5,	// 63
    -13,	// 64
    ACTION_REDUCE_MIN + 17,	// 65
    ACTION_REDUCE_MIN + 18,	// 66
    ACTION_REDUCE_MIN + 19,	// 67
    ACTION_SHIFT,	// 68
    ACTION_SHIFT,	// 69
    ACTION_SHIFT,	// 70
    ACTION_REDUCE_MIN + 12,	// 71
    ACTION_SHIFT,	// 72
    -11,	// 73
    ACTION_REDUCE_MIN + 17,	// 74
    ACTION_REDUCE_MIN + 18,	// 75
    ACTION_REDUCE_MIN + 19,	// 76
    -2,	// 77
    ACTION_SHIFT,	// 78
    ACTION_REDUCE_MIN + 20,	// 79
    ACTION_SHIFT,	// 80
    ACTION_SHIFT,	// 81
    ACTION_SHIFT,	// 82
    ACTION_SHIFT,	// 83
    ACTION_SHIFT,	// 84
    ACTION_REDUCE_MIN + 13,	// 85
    -11,	// 86
    ACTION_REDUCE_MIN + 17,	// 87
    ACTION_REDUCE_MIN + 18,	// 88
    ACTION_REDUCE_MIN + 19,	// 89
    -10,	// 90
    ACTION_REDUCE_MIN + 45,	// 91
    ACTION_REDUCE_MIN + 48,	// 92
    ACTION_REDUCE_MIN + 47,	// 93
    ACTION_REDUCE_MIN + 43,	// 94
    ACTION_REDUCE_MIN + 51,	// 95
    ACTION_REDUCE_MIN + 52,	// 96
    ACTION_REDUCE_MIN + 50,	// 97
    -10,	// 98
    ACTION_REDUCE_MIN + 41,	// 99
    ACTION_REDUCE_MIN + 46,	// 100
    ACTION_REDUCE_MIN + 44,	// 101
    ACTION_REDUCE_MIN + 12,	// 102
    ACTION_REDUCE_MIN + 20,	// 103
    ACTION_REDUCE_MIN + 13,	// 104
    -8,	// 105
    ACTION_REDUCE_MIN + 30,	// 106
    ACTION_REDUCE_MIN + 25,	// 107
    ACTION_REDUCE_MIN + 12,	// 108
    ACTION_REDUCE_MIN + 20,	// 109
    ACTION_REDUCE_MIN + 13,	// 110
    -8,	// 111
    ACTION_SHIFT,	// 112
    ACTION_REDUCE_MIN + 42,	// 113
    ACTION_REDUCE_MIN + 33,	// 114
    ACTION_SHIFT,	// 115
    ACTION_SHIFT,	// 116
    ACTION_REDUCE_MIN + 38,	// 117
    ACTION_SHIFT,	// 118
    -3,	// 119
    ACTION_REDUCE_MIN + 39,	// 120
    ACTION_REDUCE_MIN + 40,	// 121
    -9,	// 122
    ACTION_SHIFT,	// 123
    -9};	// 124

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2S_Table0[] ={
    {'#',	1},
    {'%',	2},
    {ZIP_TOKEN(TID_LEX_Id),	3},
    {ZIP_TOKEN(NID_Line),	33}},
L2S_Table1[] ={
    {'(',	24},
    {'[',	25},
    {'{',	26},
    {ZIP_TOKEN(TID_LEX_Id),	27},
    {ZIP_TOKEN(TID_LEX_Key),	28},
    {ZIP_TOKEN(TID_LEX_String),	29},
    {ZIP_TOKEN(NID_RegExprSeq),	90},
    {ZIP_TOKEN(NID_RegExprTerm),	32}},
L2S_Table2[] ={
    {'(',	24},
    {'[',	25},
    {'{',	26},
    {ZIP_TOKEN(TID_LEX_Id),	27},
    {ZIP_TOKEN(TID_LEX_Key),	28},
    {ZIP_TOKEN(TID_LEX_String),	29},
    {ZIP_TOKEN(NID_RegExprTerm),	64}},
L2S_Table3[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExpr),	68},
    {ZIP_TOKEN(NID_RegExprSeq),	42},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table4[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExpr),	81},
    {ZIP_TOKEN(NID_RegExprSeq),	42},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table5[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExprSeq),	105},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table6[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExprTerm),	73}},
L2S_Table7[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExpr),	70},
    {ZIP_TOKEN(NID_RegExprSeq),	59},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table8[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExpr),	83},
    {ZIP_TOKEN(NID_RegExprSeq),	59},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table9[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExprSeq),	111},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table10[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExprTerm),	86}},
L2S_Table11[] ={
    {')',	102},
    {'|',	72}},
L2S_Table12[] ={
    {')',	108},
    {'|',	72}},
L2S_Table13[] ={
    {'@',	112},
    {ZIP_TOKEN(TID_LEX_Id),	91},
    {ZIP_TOKEN(TID_LEX_Key),	92},
    {ZIP_TOKEN(TID_LEX_Num),	93},
    {ZIP_TOKEN(TID_LEX_Operator),	94},
    {ZIP_TOKEN(TID_KEYWORD_if),	95},
    {ZIP_TOKEN(TID_KEYWORD_include),	96},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	97},
    {ZIP_TOKEN(NID_LexTerm),	113},
    {ZIP_TOKEN(NID_WithFinalCond),	114},
    {ZIP_TOKEN(NIDa_keyword),	100},
    {ZIP_TOKEN(NIDa_operator),	101}},
L2S_Table14[] ={
    {'^',	44},
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_BW_List),	69},
    {ZIP_TOKEN(NID_SubCharSet),	51}},
L2S_Table15[] ={
    {'^',	44},
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_BW_List),	82},
    {ZIP_TOKEN(NID_SubCharSet),	51}},
L2S_Table16[] ={
    {'|',	84},
    {'}',	104}},
L2S_Table17[] ={
    {'|',	84},
    {'}',	110}},
L2S_Table18[] ={
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_SubCharSet),	77}},
L2S_Table19[] ={
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_SubCharSet),	107}},
L2S_Table20[] ={
    {ZIP_TOKEN(TID_LEX_Id),	12},
    {ZIP_TOKEN(TID_LEX_Key),	13},
    {ZIP_TOKEN(TID_LEX_Num),	14},
    {ZIP_TOKEN(TID_LEX_Operator),	15},
    {ZIP_TOKEN(TID_KEYWORD_if),	16},
    {ZIP_TOKEN(TID_KEYWORD_include),	17},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	18},
    {ZIP_TOKEN(NID_LexExpr),	122},
    {ZIP_TOKEN(NID_LexTerm),	20},
    {ZIP_TOKEN(NIDa_keyword),	22},
    {ZIP_TOKEN(NIDa_operator),	23}},
L2S_Table21[] ={
    {ZIP_TOKEN(TID_LEX_Id),	12},
    {ZIP_TOKEN(TID_LEX_Key),	13},
    {ZIP_TOKEN(TID_LEX_Num),	14},
    {ZIP_TOKEN(TID_LEX_Operator),	15},
    {ZIP_TOKEN(TID_KEYWORD_if),	16},
    {ZIP_TOKEN(TID_KEYWORD_include),	17},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	18},
    {ZIP_TOKEN(NID_LexExpr),	124},
    {ZIP_TOKEN(NID_LexTerm),	20},
    {ZIP_TOKEN(NIDa_keyword),	22},
    {ZIP_TOKEN(NIDa_operator),	23}},
L2S_Table22[] ={
    {ZIP_TOKEN(TID_LEX_Id),	12},
    {ZIP_TOKEN(TID_LEX_Key),	13},
    {ZIP_TOKEN(TID_LEX_Num),	14},
    {ZIP_TOKEN(TID_LEX_Operator),	15},
    {ZIP_TOKEN(TID_KEYWORD_if),	16},
    {ZIP_TOKEN(TID_KEYWORD_include),	17},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	18},
    {ZIP_TOKEN(NID_LexTerm),	34},
    {ZIP_TOKEN(NIDa_keyword),	22},
    {ZIP_TOKEN(NIDa_operator),	23}};

constinit const struct C_MapGoto {
    bux::U_K2V<uint8_t,uint8_t> m_k2v;
    uint8_t	m_curState;
    int8_t	m_nextStateEx;
}   mapGoto[60] ={
    {findPrime4_0_5,	0,	1},
    {isKey<ZIP_TOKEN(TID_KEYWORD_include)>,	1,	6},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	2,	7},
    {isKey<'='>,	3,	8},
    {isKey<'\n'>,	4,	9},
    {isKey<ZIP_TOKEN(TID_LEX_String)>,	6,	10},
    {findPrime14_0_13,	7,	11},
    {findPrime7_0_9,	8,	24},
    {L2S_Table0,	9,	-4},
    {L2S_Table22,	19,	-10},
    {findPrime7_0_9,	24,	35},
    {findPrime12_0_8,	25,	44},
    {findPrime7_0_9,	26,	52},
    {findPrime13_0_3,	30,	61},
    {L2S_Table2,	31,	-7},
    {findPrime9_0_3,	32,	65},
    {L2S_Table3,	35,	-9},
    {L2S_Table14,	36,	-8},
    {L2S_Table7,	37,	-9},
    {findPrime8_0_2,	41,	71},
    {L2S_Table6,	42,	-7},
    {findPrime9_0_3,	43,	74},
    {L2S_Table18,	44,	-6},
    {isKey<'-'>,	47,	78},
    {isKey<']'>,	50,	79},
    {isKey<','>,	51,	80},
    {L2S_Table4,	52,	-9},
    {L2S_Table15,	53,	-8},
    {L2S_Table8,	54,	-9},
    {findPrime6_5_2,	58,	84},
    {L2S_Table10,	59,	-7},
    {findPrime9_0_3,	60,	87},
    {L2S_Table1,	61,	-8},
    {findPrime15_0_11,	62,	91},
    {findPrime9_0_3,	64,	65},
    {L2S_Table11,	68,	-2},
    {isKey<']'>,	69,	103},
    {L2S_Table16,	70,	-2},
    {L2S_Table5,	72,	-8},
    {findPrime9_0_3,	73,	74},
    {isKey<','>,	77,	80},
    {isKey<ZIP_TOKEN(TID_LEX_Key)>,	78,	106},
    {L2S_Table19,	80,	-6},
    {L2S_Table12,	81,	-2},
    {isKey<']'>,	82,	109},
    {L2S_Table17,	83,	-2},
    {L2S_Table9,	84,	-8},
    {findPrime9_0_3,	86,	87},
    {L2S_Table2,	90,	-7},
    {L2S_Table13,	98,	-12},
    {L2S_Table6,	105,	-7},
    {L2S_Table10,	111,	-7},
    {findPrime10_0_5,	112,	115},
    {isKey<ZIP_TOKEN(TID_LEX_Num)>,	115,	120},
    {isKey<ZIP_TOKEN(TID_LEX_Num)>,	116,	121},
    {L2S_Table20,	118,	-11},
    {isKey<ZIP_TOKEN(TID_KEYWORD_if)>,	119,	123},
    {L2S_Table22,	122,	-10},
    {L2S_Table21,	123,	-11},
    {L2S_Table22,	124,	-10}};

void _reduce_1(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= # include $String
{
    const auto filename = dynamic_cast<::C_ScannerParser&>(_paRSeR_).m_context.expand_include(bux::unlex<std::string>(_geT_(2)));
    _paRSeR_.reservePostShift([&,filename]{
            parseFile(filename, dynamic_cast<::C_ScannerParser&>(_paRSeR_), '\n');
        }, 1);
}

void _reduce_2(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= % $Id <OptionValue>
{
    const auto &name = bux::unlex<std::string>(_geT_(1));
    auto &value = bux::unlex<C_StrList>(_geT_(2));
    dynamic_cast<::C_ScannerParser&>(_paRSeR_).m_context.addOption(name, value);
}

void _reduce_3(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= $Id = <RegExpr> <LexResult>
{
    const auto &name = bux::unlex<std::string>(_geT_(0));
    auto &c = dynamic_cast<::C_ScannerParser&>(_paRSeR_).m_context;
    if (c.eraseRE(name))
        _paRSeR_.onError(_geT_(0), "Duplicate regular expression name \""+name+"\"");
    auto &t = _geT_(2).m_attr;
    auto &val = dynamic_cast<C_NfaLex&>(*t);
    if (auto const action = bux::tryUnlex<C_WeightedStrList>(_geT_(3)))
    {
        action->m_1stFit = val.m_1stFit;
        val.m_NFA.setAction(std::move(*action));
    }
    c.addRE(name, val);
    t.disown(); // val (aka *t) has been taken as &val the pointer.
}

void _reduce_4(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionValue> ::= $Bracketed
//  <LexExpr> ::= <LexTerm>
{
    C_StrList t;
    t.emplace_back(bux::unlex<std::string>(_geT_(0)));
    _reT_ = bux::createLex(t);
}

void _reduce_5(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionValue> ::= <LexExpr>
//  <RegExpr> ::= <RegExprSeq>
//  <RegExprSeq> ::= <RegExprTerm>
//  <Integer> ::= $Num
//  <LexTerm> ::= $Operator
//  <LexTerm> ::= <@operator>
//  <LexTerm> ::= $Id
//  <LexTerm> ::= <@keyword>
{
    _reT_ = _geT_(0);
}

void _reduce_6(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExpr> ::= <RegExpr> | <RegExprSeq>
{
    auto        &dst = dynamic_cast<C_NfaLex&>(*_geT_(0));
    const auto  &src = dynamic_cast<C_NfaLex&>(*_geT_(2));
    dst.m_NFA |= src.m_NFA;
    dst.m_1stFit |= src.m_1stFit;
    _reT_ = _geT_(0);
}

void _reduce_7(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprSeq> ::= <RegExprSeq> <RegExprTerm>
{
    auto        &dst = dynamic_cast<C_NfaLex&>(*_geT_(0));
    const auto  &src = dynamic_cast<C_NfaLex&>(*_geT_(1));
    dst.m_NFA.append(src.m_NFA);
    dst.m_1stFit |=src.m_1stFit;
    _reT_ = _geT_(0);
}

void _reduce_8(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= ( <RegExpr> )
//  <RegExprTerm> ::= [ <BW_List> ]
//  <WithFinalCond> ::= @ <Integer>
{
    _reT_ = _geT_(1);
}

void _reduce_9(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= { <RegExpr> }
{
    dynamic_cast<C_NfaLex&>(*_geT_(1)).m_NFA.changeTo(bux::FA_OPTIONAL);
    _reT_ = _geT_(1);
}

void _reduce_10(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $Id
{
    const auto &name = bux::unlex<std::string>(_geT_(0));
    if (const auto nfa = dynamic_cast<::C_ScannerParser&>(_paRSeR_).m_context.findRE(name))
        // Clone an existing NFA
    {
        _reT_ = new C_NfaLex(*nfa);
        return;
    }
    _paRSeR_.onError(_geT_(0), "Unknown expression name \""+name+"\"");
    _reT_ = new C_NfaLex; // An idea to recover
}

void _reduce_11(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $String
{
    bux::C_NewNode<C_NfaLex> ret;
    for (auto i: bux::unlex<std::string>(_geT_(0)))
        ret->m_NFA.append(C_LexSet(uint8_t(i)));

    _reT_ = ret;
}

void _reduce_12(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $Key
{
    bux::C_NewNode<C_NfaLex> ret;
    ret->m_NFA.append(C_LexSet(bux::unlex<uint32_t>(_geT_(0))));
    _reT_ = ret;
}

void _reduce_13(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> *
{
    dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA.changeTo(bux::FA_REPEATABLE|bux::FA_OPTIONAL);
    _reT_ = _geT_(0);
}

void _reduce_14(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> +
{
    dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA.changeTo(bux::FA_REPEATABLE);
    _reT_ = _geT_(0);
}

void _reduce_15(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> $Num
{
    switch (const auto n = dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).value<unsigned>())
    {
    case 0:
        _paRSeR_.onError(_geT_(1), "Zero repeat");
        break;
    case 1:
        break;
    default:
        auto &dst = dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA;
        const auto addee{dst};
        for (unsigned i = 1; i < n; ++i)
            dst.append(addee);
    }
    _reT_ = _geT_(0);
}

void _reduce_16(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <BW_List> ::=
//  <BW_List> ::= ^
{
    bux::C_NewNode<C_NfaLex> ret;
    C_LexSet t;
    t.complement();
    ret->m_NFA.append(t);
    ret->m_1stFit = true;
    _reT_ = ret;
}

void _reduce_17(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <BW_List> ::= <SubCharSet>
{
    bux::C_NewNode<C_NfaLex> ret;
    ret->m_NFA.append(bux::unlex<C_LexSet>(_geT_(0)));
    _reT_ = ret;
}

void _reduce_18(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <BW_List> ::= ^ <SubCharSet>
{
    bux::C_NewNode<C_NfaLex> ret;
    auto &src = bux::unlex<C_LexSet>(_geT_(1));
    src.complement();
    ret->m_NFA.append(src);
    _reT_ = ret;
}

void _reduce_19(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= <SubCharSet> , <SubCharSet>
{
    bux::unlex<C_LexSet>(_geT_(0)) |= bux::unlex<C_LexSet>(_geT_(2));
    _reT_ = _geT_(0);
}

void _reduce_20(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $String
//  <SubCharSet> ::= $Id
{
    const auto t = bux::unlex<std::string>(_geT_(0));
    _reT_ = bux::createLex<C_LexSet>(t.begin(), t.end());
}

void _reduce_21(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Num
{
    const auto t = dynamic_cast<bux::C_IntegerLex&>(*_geT_(0)).str();
    _reT_ = bux::createLex<C_LexSet>(t.begin(), t.end());
}

void _reduce_22(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Key
{
    _reT_ = bux::createLex<C_LexSet>(bux::unlex<uint32_t>(_geT_(0)));
}

void _reduce_23(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Key - $Key
{
    auto c1 = bux::unlex<uint32_t>(_geT_(0));
    auto c2 = bux::unlex<uint32_t>(_geT_(2));
    if (c1 > c2)
    {
        _paRSeR_.onError(_geT_(0), "Lower bound key is greater than upper bound key");
        std::swap(c1, c2);
    }
    _reT_ = bux::createLex<C_LexSet>(c1, c2);
}

void _reduce_24(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Charset
{
    std::string s;
    if (auto errPos = spec2charset(bux::unlex<std::string>(_geT_(0)), s))
        // On error
    {
        const char *err;
        switch (errPos->second)
        {
        case SCE_INVALID_CHAR:          err = "Invalid char";       break;
        case SCE_MSSING_UB:             err = "Missing range UB";   break;
        case SCE_NOT_IN_SAME_GROUP:     err = "Not in same group";  break;
        case SCE_LB_GREATOR_THAN_UB:    err = "Range LB < UB";      break;
        default:                        err = "Unknown error";
        }
        auto pos = _geT_(0).m_pos;
        pos.m_Col += unsigned(errPos->first);
        _paRSeR_.onError(pos, err);
    }
    else
        // On success
        _reT_ = bux::createLex<C_LexSet>(s.begin(), s.end());
}

void _reduce_25(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexResult> ::= >> <LexExpr> <WithFinalCond>
{
    int w = 0;
    C_StrList *is_final = nullptr;
    auto &cond = _geT_(2).m_attr;
    if (!_geT_(2))
        ;
    else if (bux::C_IntegerLex *i = cond)
        w = i->value<int>();
    else if (auto f = bux::tryUnlex<C_StrList>(cond))
        is_final = f;
    else if (auto wf = bux::tryUnlex<std::pair<int,C_StrList>>(cond))
    {
        w = wf->first;
        is_final = &wf->second;
    }
    else
        _paRSeR_.onError(_geT_(2), "Unexpected <FinalCond> type "+HRTN(std::ref(*cond)));

    _reT_ = bux::createLex<C_WeightedStrList>(w, bux::unlex<C_StrList>(_geT_(1)), is_final);
}

void _reduce_26(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <WithFinalCond> ::= @ if <LexExpr>
{
    _reT_ = _geT_(2);
}

void _reduce_27(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <WithFinalCond> ::= @ <Integer> if <LexExpr>
{
    _reT_ = bux::createLex<std::pair<int,C_StrList>>(
            dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).value<int>(),
            std::move(bux::unlex<C_StrList>(_geT_(3))));
}

void _reduce_28(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Integer> ::= + $Num
{
    dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).prependPlus();
    _reT_ =_geT_(1);
}

void _reduce_29(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Integer> ::= - $Num
{
    dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).negate();
    _reT_ =_geT_(1);
}

void _reduce_30(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexExpr> ::= <LexExpr> <LexTerm>
{
    bux::unlex<C_StrList>(_geT_(0)).emplace_back(bux::unlex<std::string>(_geT_(1)));
    _reT_ = _geT_(0);
}

void _reduce_31(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexTerm> ::= $Num
{
    _reT_ = bux::createLex(' ' + dynamic_cast<bux::C_IntegerLex&>(*_geT_(0)).str());
}

void _reduce_32(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexTerm> ::= $Key
{
    _reT_ = bux::createLex('\'' + asciiLiteral(bux::unlex<uint32_t>(_geT_(0))) + '\'');
}

void _reduce_33(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@operator> ::= >>
{
    _reT_ = createLex<std::string>(">>");
}

void _reduce_34(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= if
{
    _reT_ = createLex<std::string>("if");
}

void _reduce_35(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= include
{
    _reT_ = createLex<std::string>("include");
}

struct C_ProductionInfo
{
    void            (*m_pAction)(bux::LR1::C_Parser&,const F_GetProduced&,C_RetLval);
    uint8_t         m_ReducedID;
    uint8_t         m_PopLength;
} constinit const prodInfo[53] ={
{nullptr,    	ZIP_TOKEN(NID_All), 1},	// 0: <All> ::= <Line>
{nullptr,    	ZIP_TOKEN(NID_All), 3},	// 1: <All> ::= <All> "\n" <Line>
{nullptr,    	ZIP_TOKEN(NID_Line), 0},	// 2: <Line> ::=
{_reduce_1, 	ZIP_TOKEN(NID_Line), 3},	// 3: <Line> ::= # include $String
{_reduce_2, 	ZIP_TOKEN(NID_Line), 3},	// 4: <Line> ::= % $Id <OptionValue>
{_reduce_3, 	ZIP_TOKEN(NID_Line), 4},	// 5: <Line> ::= $Id = <RegExpr> <LexResult>
{_reduce_4, 	ZIP_TOKEN(NID_OptionValue), 1},	// 6: <OptionValue> ::= $Bracketed
{_reduce_5, 	ZIP_TOKEN(NID_OptionValue), 1},	// 7: <OptionValue> ::= <LexExpr>
{_reduce_5, 	ZIP_TOKEN(NID_RegExpr), 1},	// 8: <RegExpr> ::= <RegExprSeq>
{_reduce_6, 	ZIP_TOKEN(NID_RegExpr), 3},	// 9: <RegExpr> ::= <RegExpr> | <RegExprSeq>
{_reduce_5, 	ZIP_TOKEN(NID_RegExprSeq), 1},	// 10: <RegExprSeq> ::= <RegExprTerm>
{_reduce_7, 	ZIP_TOKEN(NID_RegExprSeq), 2},	// 11: <RegExprSeq> ::= <RegExprSeq> <RegExprTerm>
{_reduce_8, 	ZIP_TOKEN(NID_RegExprTerm), 3},	// 12: <RegExprTerm> ::= ( <RegExpr> )
{_reduce_9, 	ZIP_TOKEN(NID_RegExprTerm), 3},	// 13: <RegExprTerm> ::= { <RegExpr> }
{_reduce_10,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 14: <RegExprTerm> ::= $Id
{_reduce_11,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 15: <RegExprTerm> ::= $String
{_reduce_12,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 16: <RegExprTerm> ::= $Key
{_reduce_13,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 17: <RegExprTerm> ::= <RegExprTerm> *
{_reduce_14,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 18: <RegExprTerm> ::= <RegExprTerm> +
{_reduce_15,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 19: <RegExprTerm> ::= <RegExprTerm> $Num
{_reduce_8, 	ZIP_TOKEN(NID_RegExprTerm), 3},	// 20: <RegExprTerm> ::= [ <BW_List> ]
{_reduce_16,	ZIP_TOKEN(NID_BW_List), 0},	// 21: <BW_List> ::=
{_reduce_16,	ZIP_TOKEN(NID_BW_List), 1},	// 22: <BW_List> ::= ^
{_reduce_17,	ZIP_TOKEN(NID_BW_List), 1},	// 23: <BW_List> ::= <SubCharSet>
{_reduce_18,	ZIP_TOKEN(NID_BW_List), 2},	// 24: <BW_List> ::= ^ <SubCharSet>
{_reduce_19,	ZIP_TOKEN(NID_SubCharSet), 3},	// 25: <SubCharSet> ::= <SubCharSet> , <SubCharSet>
{_reduce_20,	ZIP_TOKEN(NID_SubCharSet), 1},	// 26: <SubCharSet> ::= $String
{_reduce_20,	ZIP_TOKEN(NID_SubCharSet), 1},	// 27: <SubCharSet> ::= $Id
{_reduce_21,	ZIP_TOKEN(NID_SubCharSet), 1},	// 28: <SubCharSet> ::= $Num
{_reduce_22,	ZIP_TOKEN(NID_SubCharSet), 1},	// 29: <SubCharSet> ::= $Key
{_reduce_23,	ZIP_TOKEN(NID_SubCharSet), 3},	// 30: <SubCharSet> ::= $Key - $Key
{_reduce_24,	ZIP_TOKEN(NID_SubCharSet), 1},	// 31: <SubCharSet> ::= $Charset
{nullptr,    	ZIP_TOKEN(NID_LexResult), 0},	// 32: <LexResult> ::=
{_reduce_25,	ZIP_TOKEN(NID_LexResult), 3},	// 33: <LexResult> ::= >> <LexExpr> <WithFinalCond>
{nullptr,    	ZIP_TOKEN(NID_WithFinalCond), 0},	// 34: <WithFinalCond> ::=
{_reduce_8, 	ZIP_TOKEN(NID_WithFinalCond), 2},	// 35: <WithFinalCond> ::= @ <Integer>
{_reduce_26,	ZIP_TOKEN(NID_WithFinalCond), 3},	// 36: <WithFinalCond> ::= @ if <LexExpr>
{_reduce_27,	ZIP_TOKEN(NID_WithFinalCond), 4},	// 37: <WithFinalCond> ::= @ <Integer> if <LexExpr>
{_reduce_5, 	ZIP_TOKEN(NID_Integer), 1},	// 38: <Integer> ::= $Num
{_reduce_28,	ZIP_TOKEN(NID_Integer), 2},	// 39: <Integer> ::= + $Num
{_reduce_29,	ZIP_TOKEN(NID_Integer), 2},	// 40: <Integer> ::= - $Num
{_reduce_4, 	ZIP_TOKEN(NID_LexExpr), 1},	// 41: <LexExpr> ::= <LexTerm>
{_reduce_30,	ZIP_TOKEN(NID_LexExpr), 2},	// 42: <LexExpr> ::= <LexExpr> <LexTerm>
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm), 1},	// 43: <LexTerm> ::= $Operator
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm), 1},	// 44: <LexTerm> ::= <@operator>
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm), 1},	// 45: <LexTerm> ::= $Id
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm), 1},	// 46: <LexTerm> ::= <@keyword>
{_reduce_31,	ZIP_TOKEN(NID_LexTerm), 1},	// 47: <LexTerm> ::= $Num
{_reduce_32,	ZIP_TOKEN(NID_LexTerm), 1},	// 48: <LexTerm> ::= $Key
{nullptr,    	ZIP_TOKEN(bux::ROOT_NID), 1},	// 49: <@> ::= <All>
{_reduce_33,	ZIP_TOKEN(NIDa_operator), 1},	// 50: <@operator> ::= >>
{_reduce_34,	ZIP_TOKEN(NIDa_keyword), 1},	// 51: <@keyword> ::= if
{_reduce_35,	ZIP_TOKEN(NIDa_keyword), 1} 	// 52: <@keyword> ::= include
};

struct C_ActionTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&) { return static_cast<uint8_t>(t1); }
    static uint8_t valueError() { return ACTION_ERROR; }
};

struct C_ShiftTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&t2) { return static_cast<uint8_t>(t1+t2); }
    static uint8_t valueError() { RUNTIME_ERROR("SHIFT ERROR"); }
};

//
//   Generated Parser Policy
//
class C_ParserPolicy: public I_ParserPolicy
{
public:

    // Ctor
    C_ParserPolicy(): I_ParserPolicy(TOKENGEN_UB+2) {}

    // Implement I_ParserPolicy
    size_t action(bux::T_StateID state, bux::T_LexID token) const override;
    size_t getAcceptId() const override;
    bool getTokenName(bux::T_LexID token, std::string &name) const override;
    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;
    bool changeToken(bux::T_LexID &token, C_LexPtr &attr) const override;
    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;
    void onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, std::string_view message) const override;
}   g_policy;

size_t C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        return ACTION_ERROR;

    return index2value<uint8_t,uint8_t,int8_t,C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);
}

size_t C_ParserPolicy::getAcceptId() const
{
    return 49;
}

bool C_ParserPolicy::getTokenName(bux::T_LexID token, std::string &name) const
{
    static constinit char const *const NAMES[26] = {
        "$Bracketed",
        "$Charset",
        "$Id",
        "$Key",
        "$Num",
        "$Operator",
        "$Spaces",
        "$String",
        "\"if\"",
        "\"include\"",
        "\">>\"",
        "<All>",
        "<BW_List>",
        "<Integer>",
        "<LexExpr>",
        "<LexResult>",
        "<LexTerm>",
        "<Line>",
        "<OptionValue>",
        "<RegExpr>",
        "<RegExprSeq>",
        "<RegExprTerm>",
        "<SubCharSet>",
        "<WithFinalCond>",
        "<@keyword>",
        "<@operator>"};
    if (bux::TOKENGEN_LB <= token && token < bux::TOKENGEN_LB + 26)
    {
        name = NAMES[token - bux::TOKENGEN_LB];
        return true;
    }
    return false;
}

bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        LOGIC_ERROR("Invalid input: state={} input={}", (int)state, printToken(input));

    auto end = mapGoto + 60;
    auto found = std::lower_bound(mapGoto, end, state, [](const C_MapGoto &i, bux::T_StateID state_) {
        return i.m_curState < state_;
    });
    if (found != end && found->m_curState == state)
        return index2value<uint8_t,uint8_t,int8_t,C_ShiftTraits>(found->m_k2v, found->m_nextStateEx, input);

    RUNTIME_ERROR("Invalid state: state={} input={}", (int)state, printToken(input));
}

bool C_ParserPolicy::changeToken(T_LexID &token, C_LexPtr &attr) const
{
    // Grammar %UPCAST_TOKEN begins
    if (const auto it = int(token); isascii(it) && !iscntrl(it) && !isalnum(it) && !isspace(it))
    {
        attr.assign(bux::createLex<std::string>(1u,char(token)), true);
        token = TID_LEX_Operator;
        return true;
    }
    return false;
    // Grammar %UPCAST_TOKEN ends
}

void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const
{
    const auto &src  = prodInfo[id];
    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB);
    info.m_PopLength = src.m_PopLength;
    info.m_Reduce    = src.m_pAction;
}

void C_ParserPolicy::onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, std::string_view message) const
{
    // Grammar %ON_ERROR begins
    dynamic_cast<::C_ScannerParser&>(_paRSeR_).m_context.log(LL_ERROR, pos, message);
    // Grammar %ON_ERROR ends
}

} // namespace

const bux::LR1::I_ParserPolicy &::C_ScannerParser::policy() { return g_policy; }
