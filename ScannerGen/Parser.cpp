// This file is fully generated by running parsergen
// with grammer definition file grammar.txt
// Read ParserGen.chm for further info.

// %HEADERS_FOR_CPP expanded BEGIN
#include "spec2charset.h"   // spec2charset()
#include <bux/LexBase.h>    // bux::T_LexID
#include <bux/LogStream.h>  // HRTN()

void parseFile(const std::string &filename, class C_ScannerParser &parser, bux::T_LexID endToken);
// %HEADERS_FOR_CPP expanded END
#include "Parser.h"
#include "ParserIdDef.h"
#include <bux/ImplLR1.h>
#include <bux/XException.h>

namespace {

using namespace bux::LR1;

// %LOCAL_CPP expanded BEGIN
using namespace bux;

//
//      In-Module Types
//
typedef bux::C_Stack<bux::T_LexID> C_IdStack;

struct C_LexListLex: bux::I_LexAttr
{
    // Data
    C_IdStack list;

    // Nonvirtuals
    C_LexListLex()
        {}
    template<class T_Iter>
    C_LexListLex(T_Iter beg, T_Iter end)
        { list.push(beg, end); }
};
// %LOCAL_CPP expanded END

//
//   Generated Constants
//
enum
{
    NID_All                = TID_UB_+0,	// <All>
    NID_BW_List            = TID_UB_+1,	// <BW_List>
    NID_FinalCond          = TID_UB_+2,	// <FinalCond>
    NID_IfFinal            = TID_UB_+3,	// <IfFinal>
    NID_Integer            = TID_UB_+4,	// <Integer>
    NID_LexExpr            = TID_UB_+5,	// <LexExpr>
    NID_LexResult          = TID_UB_+6,	// <LexResult>
    NID_LexTerm            = TID_UB_+7,	// <LexTerm>
    NID_Line               = TID_UB_+8,	// <Line>
    NID_OptionValue        = TID_UB_+9,	// <OptionValue>
    NID_OptionalIfFinal    = TID_UB_+10,	// <OptionalIfFinal>
    NID_OptionalSubCharSet = TID_UB_+11,	// <OptionalSubCharSet>
    NID_OptionalUBKey      = TID_UB_+12,	// <OptionalUBKey>
    NID_RegExpr            = TID_UB_+13,	// <RegExpr>
    NID_RegExprSeq         = TID_UB_+14,	// <RegExprSeq>
    NID_RegExprTerm        = TID_UB_+15,	// <RegExprTerm>
    NID_SubCharSet         = TID_UB_+16,	// <SubCharSet>
    NID_WithFinalCond      = TID_UB_+17,	// <WithFinalCond>
    NIDa_keyword           = TID_UB_+18,	// <@keyword>
    NIDa_operator          = TID_UB_+19,	// <@operator>
    TOKENGEN_UB,
    //---------------------------------------------------
    ENCODED_TOKEN_LB	 = 126
};
#define ZIP_TOKEN(x) (x-(bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB))

constinit const uint8_t
alphaPrime0[13] = {
    '\n',
    '(',
    '*',
    '+',
    '[',
    '{',
    '|',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime1[10] = {
    '\n',
    '@',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime2[9] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e)},
alphaPrime3[3] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_KEYWORD_if)},
alphaPrime4[5] = {
    '#',
    '%',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_All),
    ZIP_TOKEN(NID_Line)},
alphaPrime5[11] = {
    '(',
    ')',
    '*',
    '+',
    '[',
    '{',
    '|',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String)},
alphaPrime6[11] = {
    '(',
    '*',
    '+',
    '[',
    '{',
    '|',
    '}',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String)},
alphaPrime7[9] = {
    '(',
    '[',
    '{',
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(NID_RegExpr),
    ZIP_TOKEN(NID_RegExprSeq),
    ZIP_TOKEN(NID_RegExprTerm)},
alphaPrime8[2] = {
    ')',
    '|'},
alphaPrime9[3] = {
    '*',
    '+',
    ZIP_TOKEN(TID_LEX_Num)},
alphaPrime10[7] = {
    '+',
    '-',
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(NID_FinalCond),
    ZIP_TOKEN(NID_IfFinal),
    ZIP_TOKEN(NID_Integer)},
alphaPrime11[2] = {
    ',',
    ']'},
alphaPrime12[2] = {
    '-',
    ZIP_TOKEN(NID_OptionalUBKey)},
alphaPrime13[8] = {
    '^',
    ZIP_TOKEN(TID_LEX_Charset),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(NID_BW_List),
    ZIP_TOKEN(NID_SubCharSet)},
alphaPrime14[3] = {
    '|',
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexResult)},
alphaPrime15[13] = {
    ZIP_TOKEN(TID_LEX_Bracketed),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexExpr),
    ZIP_TOKEN(NID_LexTerm),
    ZIP_TOKEN(NID_OptionValue),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)},
alphaPrime16[11] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_KEYWORD_if),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_LITERAL_3e3e),
    ZIP_TOKEN(NID_LexExpr),
    ZIP_TOKEN(NID_LexTerm),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)};

template<uint8_t KEY> int isKey(uint8_t key)
{
    return key == KEY? 0: -1;
}

int findKey(const uint8_t *klist, int n, uint8_t key)
{
    for (int i = 0; i < n; ++i)
         if (key == klist[i])
             return i;
    return -1;
}

int findPrime0_0_13	(uint8_t key)	{ return findKey(alphaPrime0,13,key); }
int findPrime10_0_4	(uint8_t key)	{ return findKey(alphaPrime10,4,key); }
int findPrime10_0_7	(uint8_t key)	{ return findKey(alphaPrime10,7,key); }
int findPrime11_0_2	(uint8_t key)	{ return findKey(alphaPrime11,2,key); }
int findPrime12_0_2	(uint8_t key)	{ return findKey(alphaPrime12,2,key); }
int findPrime13_0_8	(uint8_t key)	{ return findKey(alphaPrime13,8,key); }
int findPrime13_1_5	(uint8_t key)	{ return findKey(alphaPrime13+1,5,key); }
int findPrime14_0_3	(uint8_t key)	{ return findKey(alphaPrime14,3,key); }
int findPrime15_0_13	(uint8_t key)	{ return findKey(alphaPrime15,13,key); }
int findPrime15_0_8	(uint8_t key)	{ return findKey(alphaPrime15,8,key); }
int findPrime16_0_11	(uint8_t key)	{ return findKey(alphaPrime16,11,key); }
int findPrime1_0_10	(uint8_t key)	{ return findKey(alphaPrime1,10,key); }
int findPrime1_3_7	(uint8_t key)	{ return findKey(alphaPrime1+3,7,key); }
int findPrime2_0_2	(uint8_t key)	{ return findKey(alphaPrime2,2,key); }
int findPrime2_0_9	(uint8_t key)	{ return findKey(alphaPrime2,9,key); }
int findPrime3_0_3	(uint8_t key)	{ return findKey(alphaPrime3,3,key); }
int findPrime4_0_5	(uint8_t key)	{ return findKey(alphaPrime4,5,key); }
int findPrime5_0_11	(uint8_t key)	{ return findKey(alphaPrime5,11,key); }
int findPrime6_0_11	(uint8_t key)	{ return findKey(alphaPrime6,11,key); }
int findPrime6_5_2	(uint8_t key)	{ return findKey(alphaPrime6+5,2,key); }
int findPrime7_0_6	(uint8_t key)	{ return findKey(alphaPrime7,6,key); }
int findPrime7_0_9	(uint8_t key)	{ return findKey(alphaPrime7,9,key); }
int findPrime8_0_2	(uint8_t key)	{ return findKey(alphaPrime8,2,key); }
int findPrime9_0_3	(uint8_t key)	{ return findKey(alphaPrime9,3,key); }

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2A_Table0[] ={
    {'\n',	ACTION_REDUCE_MIN + 2},
    {'#',	ACTION_SHIFT},
    {'%',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 2},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT}},
L2A_Table1[] ={
    {'\n',	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table2[] ={
    {'\n',	ACTION_REDUCE_MIN + 8},
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 8}},
L2A_Table3[] ={
    {'\n',	ACTION_REDUCE_MIN + 9},
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 9}},
L2A_Table4[] ={
    {'\n',	ACTION_REDUCE_MIN + 10},
    {'(',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 10}},
L2A_Table5[] ={
    {'\n',	ACTION_REDUCE_MIN + 11},
    {'(',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_REDUCE_MIN + 11}},
L2A_Table6[] ={
    {'\n',	ACTION_REDUCE_MIN + 34},
    {'|',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 34},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table7[] ={
    {'\n',	ACTION_REDUCE_MIN + 36},
    {'@',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 36},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table8[] ={
    {'\n',	ACTION_REDUCE_MIN + 40},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 40},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT}},
L2A_Table9[] ={
    {'\n',	ACTION_REDUCE_MIN + 42},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 42},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_if),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	ACTION_SHIFT}},
L2A_Table10[] ={
    {'\n',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_ACCEPT}},
L2A_Table11[] ={
    {'(',	ACTION_REDUCE_MIN + 10},
    {')',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10}},
L2A_Table12[] ={
    {'(',	ACTION_REDUCE_MIN + 10},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 10},
    {'{',	ACTION_REDUCE_MIN + 10},
    {'|',	ACTION_REDUCE_MIN + 10},
    {'}',	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 10},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 10}},
L2A_Table13[] ={
    {'(',	ACTION_REDUCE_MIN + 11},
    {')',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11}},
L2A_Table14[] ={
    {'(',	ACTION_REDUCE_MIN + 11},
    {'*',	ACTION_SHIFT},
    {'+',	ACTION_SHIFT},
    {'[',	ACTION_REDUCE_MIN + 11},
    {'{',	ACTION_REDUCE_MIN + 11},
    {'|',	ACTION_REDUCE_MIN + 11},
    {'}',	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_REDUCE_MIN + 11},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_REDUCE_MIN + 11}},
L2A_Table15[] ={
    {'(',	ACTION_SHIFT},
    {')',	ACTION_REDUCE_MIN + 8},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table16[] ={
    {'(',	ACTION_SHIFT},
    {')',	ACTION_REDUCE_MIN + 9},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table17[] ={
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 8},
    {'}',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table18[] ={
    {'(',	ACTION_SHIFT},
    {'[',	ACTION_SHIFT},
    {'{',	ACTION_SHIFT},
    {'|',	ACTION_REDUCE_MIN + 9},
    {'}',	ACTION_REDUCE_MIN + 9},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table19[] ={
    {']',	ACTION_REDUCE_MIN + 21},
    {'^',	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Charset),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table20[] ={
    {']',	ACTION_REDUCE_MIN + 24},
    {ZIP_TOKEN(TID_LEX_Charset),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT}},
L2A_Table21[] ={
    {',',	ACTION_REDUCE_MIN + 32},
    {'-',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 32}},
L2A_Table22[] ={
    {',',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 22}},
L2A_Table23[] ={
    {',',	ACTION_SHIFT},
    {']',	ACTION_REDUCE_MIN + 25}};

constinit const bux::U_K2V<uint8_t,uint8_t> mapActionPtr[129] ={
    L2A_Table0,	// 0
    isKey<ZIP_TOKEN(TID_KEYWORD_include)>,	// 1
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 2
    isKey<'='>,	// 3
    L2A_Table10,	// 4
    findPrime2_0_2,	// 5
    isKey<ZIP_TOKEN(TID_LEX_String)>,	// 6
    findPrime15_0_8,	// 7
    findPrime7_0_6,	// 8
    L2A_Table0,	// 9
    findPrime2_0_2,	// 10
    findPrime2_0_2,	// 11
    findPrime2_0_9,	// 12
    findPrime2_0_9,	// 13
    findPrime2_0_9,	// 14
    findPrime2_0_9,	// 15
    findPrime2_0_9,	// 16
    findPrime2_0_9,	// 17
    findPrime2_0_9,	// 18
    L2A_Table1,	// 19
    findPrime2_0_9,	// 20
    findPrime2_0_2,	// 21
    findPrime2_0_9,	// 22
    findPrime2_0_9,	// 23
    findPrime7_0_6,	// 24
    L2A_Table19,	// 25
    findPrime7_0_6,	// 26
    findPrime0_0_13,	// 27
    findPrime0_0_13,	// 28
    findPrime0_0_13,	// 29
    L2A_Table6,	// 30
    L2A_Table2,	// 31
    L2A_Table4,	// 32
    findPrime2_0_2,	// 33
    findPrime2_0_9,	// 34
    findPrime7_0_6,	// 35
    L2A_Table19,	// 36
    findPrime7_0_6,	// 37
    findPrime5_0_11,	// 38
    findPrime5_0_11,	// 39
    findPrime5_0_11,	// 40
    findPrime8_0_2,	// 41
    L2A_Table15,	// 42
    L2A_Table11,	// 43
    L2A_Table20,	// 44
    findPrime11_0_2,	// 45
    findPrime11_0_2,	// 46
    L2A_Table21,	// 47
    findPrime11_0_2,	// 48
    findPrime11_0_2,	// 49
    isKey<']'>,	// 50
    L2A_Table22,	// 51
    findPrime7_0_6,	// 52
    L2A_Table19,	// 53
    findPrime7_0_6,	// 54
    findPrime6_0_11,	// 55
    findPrime6_0_11,	// 56
    findPrime6_0_11,	// 57
    findPrime6_5_2,	// 58
    L2A_Table17,	// 59
    L2A_Table12,	// 60
    findPrime7_0_6,	// 61
    findPrime1_3_7,	// 62
    findPrime2_0_2,	// 63
    L2A_Table5,	// 64
    findPrime0_0_13,	// 65
    findPrime0_0_13,	// 66
    findPrime0_0_13,	// 67
    findPrime8_0_2,	// 68
    isKey<']'>,	// 69
    findPrime6_5_2,	// 70
    findPrime0_0_13,	// 71
    findPrime7_0_6,	// 72
    L2A_Table13,	// 73
    findPrime5_0_11,	// 74
    findPrime5_0_11,	// 75
    findPrime5_0_11,	// 76
    isKey<']'>,	// 77
    L2A_Table23,	// 78
    isKey<ZIP_TOKEN(TID_LEX_Key)>,	// 79
    findPrime11_0_2,	// 80
    findPrime0_0_13,	// 81
    findPrime13_1_5,	// 82
    findPrime8_0_2,	// 83
    isKey<']'>,	// 84
    findPrime6_5_2,	// 85
    findPrime7_0_6,	// 86
    findPrime0_0_13,	// 87
    L2A_Table14,	// 88
    findPrime6_0_11,	// 89
    findPrime6_0_11,	// 90
    findPrime6_0_11,	// 91
    L2A_Table3,	// 92
    findPrime1_0_10,	// 93
    findPrime1_0_10,	// 94
    findPrime1_0_10,	// 95
    findPrime1_0_10,	// 96
    findPrime1_0_10,	// 97
    findPrime1_0_10,	// 98
    findPrime1_0_10,	// 99
    L2A_Table7,	// 100
    findPrime1_0_10,	// 101
    findPrime1_0_10,	// 102
    findPrime1_0_10,	// 103
    findPrime5_0_11,	// 104
    findPrime5_0_11,	// 105
    findPrime5_0_11,	// 106
    L2A_Table16,	// 107
    findPrime11_0_2,	// 108
    findPrime11_0_2,	// 109
    findPrime6_0_11,	// 110
    findPrime6_0_11,	// 111
    findPrime6_0_11,	// 112
    L2A_Table18,	// 113
    findPrime10_0_4,	// 114
    findPrime1_0_10,	// 115
    findPrime2_0_2,	// 116
    isKey<ZIP_TOKEN(TID_LEX_Num)>,	// 117
    isKey<ZIP_TOKEN(TID_LEX_Num)>,	// 118
    findPrime3_0_3,	// 119
    findPrime1_3_7,	// 120
    findPrime2_0_2,	// 121
    findPrime2_0_2,	// 122
    L2A_Table8,	// 123
    findPrime3_0_3,	// 124
    findPrime3_0_3,	// 125
    L2A_Table9,	// 126
    findPrime2_0_2,	// 127
    findPrime2_0_2};	// 128

constinit const int8_t mapActionSizeEx[129] ={
    -5,	// 0
    ACTION_SHIFT,	// 1
    ACTION_SHIFT,	// 2
    ACTION_SHIFT,	// 3
    -2,	// 4
    ACTION_REDUCE_MIN + 0,	// 5
    ACTION_SHIFT,	// 6
    ACTION_SHIFT,	// 7
    ACTION_SHIFT,	// 8
    -5,	// 9
    ACTION_REDUCE_MIN + 3,	// 10
    ACTION_REDUCE_MIN + 6,	// 11
    ACTION_REDUCE_MIN + 50,	// 12
    ACTION_REDUCE_MIN + 53,	// 13
    ACTION_REDUCE_MIN + 52,	// 14
    ACTION_REDUCE_MIN + 48,	// 15
    ACTION_REDUCE_MIN + 56,	// 16
    ACTION_REDUCE_MIN + 57,	// 17
    ACTION_REDUCE_MIN + 55,	// 18
    -9,	// 19
    ACTION_REDUCE_MIN + 46,	// 20
    ACTION_REDUCE_MIN + 4,	// 21
    ACTION_REDUCE_MIN + 51,	// 22
    ACTION_REDUCE_MIN + 49,	// 23
    ACTION_SHIFT,	// 24
    -7,	// 25
    ACTION_SHIFT,	// 26
    ACTION_REDUCE_MIN + 14,	// 27
    ACTION_REDUCE_MIN + 16,	// 28
    ACTION_REDUCE_MIN + 15,	// 29
    -4,	// 30
    -10,	// 31
    -13,	// 32
    ACTION_REDUCE_MIN + 1,	// 33
    ACTION_REDUCE_MIN + 47,	// 34
    ACTION_SHIFT,	// 35
    -7,	// 36
    ACTION_SHIFT,	// 37
    ACTION_REDUCE_MIN + 14,	// 38
    ACTION_REDUCE_MIN + 16,	// 39
    ACTION_REDUCE_MIN + 15,	// 40
    ACTION_SHIFT,	// 41
    -8,	// 42
    -11,	// 43
    -6,	// 44
    ACTION_REDUCE_MIN + 31,	// 45
    ACTION_REDUCE_MIN + 28,	// 46
    -3,	// 47
    ACTION_REDUCE_MIN + 29,	// 48
    ACTION_REDUCE_MIN + 27,	// 49
    ACTION_SHIFT,	// 50
    -2,	// 51
    ACTION_SHIFT,	// 52
    -7,	// 53
    ACTION_SHIFT,	// 54
    ACTION_REDUCE_MIN + 14,	// 55
    ACTION_REDUCE_MIN + 16,	// 56
    ACTION_REDUCE_MIN + 15,	// 57
    ACTION_SHIFT,	// 58
    -8,	// 59
    -11,	// 60
    ACTION_SHIFT,	// 61
    ACTION_SHIFT,	// 62
    ACTION_REDUCE_MIN + 5,	// 63
    -13,	// 64
    ACTION_REDUCE_MIN + 17,	// 65
    ACTION_REDUCE_MIN + 18,	// 66
    ACTION_REDUCE_MIN + 19,	// 67
    ACTION_SHIFT,	// 68
    ACTION_SHIFT,	// 69
    ACTION_SHIFT,	// 70
    ACTION_REDUCE_MIN + 12,	// 71
    ACTION_SHIFT,	// 72
    -11,	// 73
    ACTION_REDUCE_MIN + 17,	// 74
    ACTION_REDUCE_MIN + 18,	// 75
    ACTION_REDUCE_MIN + 19,	// 76
    ACTION_REDUCE_MIN + 23,	// 77
    -2,	// 78
    ACTION_SHIFT,	// 79
    ACTION_REDUCE_MIN + 30,	// 80
    ACTION_REDUCE_MIN + 20,	// 81
    ACTION_SHIFT,	// 82
    ACTION_SHIFT,	// 83
    ACTION_SHIFT,	// 84
    ACTION_SHIFT,	// 85
    ACTION_SHIFT,	// 86
    ACTION_REDUCE_MIN + 13,	// 87
    -11,	// 88
    ACTION_REDUCE_MIN + 17,	// 89
    ACTION_REDUCE_MIN + 18,	// 90
    ACTION_REDUCE_MIN + 19,	// 91
    -10,	// 92
    ACTION_REDUCE_MIN + 50,	// 93
    ACTION_REDUCE_MIN + 53,	// 94
    ACTION_REDUCE_MIN + 52,	// 95
    ACTION_REDUCE_MIN + 48,	// 96
    ACTION_REDUCE_MIN + 56,	// 97
    ACTION_REDUCE_MIN + 57,	// 98
    ACTION_REDUCE_MIN + 55,	// 99
    -10,	// 100
    ACTION_REDUCE_MIN + 46,	// 101
    ACTION_REDUCE_MIN + 51,	// 102
    ACTION_REDUCE_MIN + 49,	// 103
    ACTION_REDUCE_MIN + 12,	// 104
    ACTION_REDUCE_MIN + 20,	// 105
    ACTION_REDUCE_MIN + 13,	// 106
    -8,	// 107
    ACTION_REDUCE_MIN + 33,	// 108
    ACTION_REDUCE_MIN + 26,	// 109
    ACTION_REDUCE_MIN + 12,	// 110
    ACTION_REDUCE_MIN + 20,	// 111
    ACTION_REDUCE_MIN + 13,	// 112
    -8,	// 113
    ACTION_SHIFT,	// 114
    ACTION_REDUCE_MIN + 47,	// 115
    ACTION_REDUCE_MIN + 35,	// 116
    ACTION_SHIFT,	// 117
    ACTION_SHIFT,	// 118
    ACTION_REDUCE_MIN + 43,	// 119
    ACTION_SHIFT,	// 120
    ACTION_REDUCE_MIN + 37,	// 121
    ACTION_REDUCE_MIN + 39,	// 122
    -3,	// 123
    ACTION_REDUCE_MIN + 44,	// 124
    ACTION_REDUCE_MIN + 45,	// 125
    -9,	// 126
    ACTION_REDUCE_MIN + 41,	// 127
    ACTION_REDUCE_MIN + 38};	// 128

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2S_Table0[] ={
    {'#',	1},
    {'%',	2},
    {ZIP_TOKEN(TID_LEX_Id),	3},
    {ZIP_TOKEN(NID_Line),	33}},
L2S_Table1[] ={
    {'(',	24},
    {'[',	25},
    {'{',	26},
    {ZIP_TOKEN(TID_LEX_Id),	27},
    {ZIP_TOKEN(TID_LEX_Key),	28},
    {ZIP_TOKEN(TID_LEX_String),	29},
    {ZIP_TOKEN(NID_RegExprSeq),	92},
    {ZIP_TOKEN(NID_RegExprTerm),	32}},
L2S_Table2[] ={
    {'(',	24},
    {'[',	25},
    {'{',	26},
    {ZIP_TOKEN(TID_LEX_Id),	27},
    {ZIP_TOKEN(TID_LEX_Key),	28},
    {ZIP_TOKEN(TID_LEX_String),	29},
    {ZIP_TOKEN(NID_RegExprTerm),	64}},
L2S_Table3[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExpr),	68},
    {ZIP_TOKEN(NID_RegExprSeq),	42},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table4[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExpr),	83},
    {ZIP_TOKEN(NID_RegExprSeq),	42},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table5[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExprSeq),	107},
    {ZIP_TOKEN(NID_RegExprTerm),	43}},
L2S_Table6[] ={
    {'(',	35},
    {'[',	36},
    {'{',	37},
    {ZIP_TOKEN(TID_LEX_Id),	38},
    {ZIP_TOKEN(TID_LEX_Key),	39},
    {ZIP_TOKEN(TID_LEX_String),	40},
    {ZIP_TOKEN(NID_RegExprTerm),	73}},
L2S_Table7[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExpr),	70},
    {ZIP_TOKEN(NID_RegExprSeq),	59},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table8[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExpr),	85},
    {ZIP_TOKEN(NID_RegExprSeq),	59},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table9[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExprSeq),	113},
    {ZIP_TOKEN(NID_RegExprTerm),	60}},
L2S_Table10[] ={
    {'(',	52},
    {'[',	53},
    {'{',	54},
    {ZIP_TOKEN(TID_LEX_Id),	55},
    {ZIP_TOKEN(TID_LEX_Key),	56},
    {ZIP_TOKEN(TID_LEX_String),	57},
    {ZIP_TOKEN(NID_RegExprTerm),	88}},
L2S_Table11[] ={
    {')',	104},
    {'|',	72}},
L2S_Table12[] ={
    {')',	110},
    {'|',	72}},
L2S_Table13[] ={
    {'@',	114},
    {ZIP_TOKEN(TID_LEX_Id),	93},
    {ZIP_TOKEN(TID_LEX_Key),	94},
    {ZIP_TOKEN(TID_LEX_Num),	95},
    {ZIP_TOKEN(TID_LEX_Operator),	96},
    {ZIP_TOKEN(TID_KEYWORD_if),	97},
    {ZIP_TOKEN(TID_KEYWORD_include),	98},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	99},
    {ZIP_TOKEN(NID_LexTerm),	115},
    {ZIP_TOKEN(NID_WithFinalCond),	116},
    {ZIP_TOKEN(NIDa_keyword),	102},
    {ZIP_TOKEN(NIDa_operator),	103}},
L2S_Table14[] ={
    {'^',	44},
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_BW_List),	69},
    {ZIP_TOKEN(NID_SubCharSet),	51}},
L2S_Table15[] ={
    {'^',	44},
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_BW_List),	84},
    {ZIP_TOKEN(NID_SubCharSet),	51}},
L2S_Table16[] ={
    {'|',	86},
    {'}',	106}},
L2S_Table17[] ={
    {'|',	86},
    {'}',	112}},
L2S_Table18[] ={
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_OptionalSubCharSet),	77},
    {ZIP_TOKEN(NID_SubCharSet),	78}},
L2S_Table19[] ={
    {ZIP_TOKEN(TID_LEX_Charset),	45},
    {ZIP_TOKEN(TID_LEX_Id),	46},
    {ZIP_TOKEN(TID_LEX_Key),	47},
    {ZIP_TOKEN(TID_LEX_Num),	48},
    {ZIP_TOKEN(TID_LEX_String),	49},
    {ZIP_TOKEN(NID_SubCharSet),	109}},
L2S_Table20[] ={
    {ZIP_TOKEN(TID_LEX_Id),	12},
    {ZIP_TOKEN(TID_LEX_Key),	13},
    {ZIP_TOKEN(TID_LEX_Num),	14},
    {ZIP_TOKEN(TID_LEX_Operator),	15},
    {ZIP_TOKEN(TID_KEYWORD_if),	16},
    {ZIP_TOKEN(TID_KEYWORD_include),	17},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	18},
    {ZIP_TOKEN(NID_LexExpr),	126},
    {ZIP_TOKEN(NID_LexTerm),	20},
    {ZIP_TOKEN(NIDa_keyword),	22},
    {ZIP_TOKEN(NIDa_operator),	23}},
L2S_Table21[] ={
    {ZIP_TOKEN(TID_LEX_Id),	12},
    {ZIP_TOKEN(TID_LEX_Key),	13},
    {ZIP_TOKEN(TID_LEX_Num),	14},
    {ZIP_TOKEN(TID_LEX_Operator),	15},
    {ZIP_TOKEN(TID_KEYWORD_if),	16},
    {ZIP_TOKEN(TID_KEYWORD_include),	17},
    {ZIP_TOKEN(TID_LITERAL_3e3e),	18},
    {ZIP_TOKEN(NID_LexTerm),	34},
    {ZIP_TOKEN(NIDa_keyword),	22},
    {ZIP_TOKEN(NIDa_operator),	23}},
L2S_Table22[] ={
    {ZIP_TOKEN(TID_KEYWORD_if),	120},
    {ZIP_TOKEN(NID_IfFinal),	127},
    {ZIP_TOKEN(NID_OptionalIfFinal),	128}};

constinit const struct C_MapGoto {
    bux::U_K2V<uint8_t,uint8_t> m_k2v;
    uint8_t	m_curState;
    int16_t	m_nextStateEx;
}   mapGoto[58] ={
    {findPrime4_0_5,	0,	1},
    {isKey<ZIP_TOKEN(TID_KEYWORD_include)>,	1,	6},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	2,	7},
    {isKey<'='>,	3,	8},
    {isKey<'\n'>,	4,	9},
    {isKey<ZIP_TOKEN(TID_LEX_String)>,	6,	10},
    {findPrime15_0_13,	7,	11},
    {findPrime7_0_9,	8,	24},
    {L2S_Table0,	9,	-4},
    {L2S_Table21,	19,	-10},
    {findPrime7_0_9,	24,	35},
    {findPrime13_0_8,	25,	44},
    {findPrime7_0_9,	26,	52},
    {findPrime14_0_3,	30,	61},
    {L2S_Table2,	31,	-7},
    {findPrime9_0_3,	32,	65},
    {L2S_Table3,	35,	-9},
    {L2S_Table14,	36,	-8},
    {L2S_Table7,	37,	-9},
    {findPrime8_0_2,	41,	71},
    {L2S_Table6,	42,	-7},
    {findPrime9_0_3,	43,	74},
    {L2S_Table18,	44,	-7},
    {findPrime12_0_2,	47,	79},
    {isKey<']'>,	50,	81},
    {isKey<','>,	51,	82},
    {L2S_Table4,	52,	-9},
    {L2S_Table15,	53,	-8},
    {L2S_Table8,	54,	-9},
    {findPrime6_5_2,	58,	86},
    {L2S_Table10,	59,	-7},
    {findPrime9_0_3,	60,	89},
    {L2S_Table1,	61,	-8},
    {findPrime16_0_11,	62,	93},
    {findPrime9_0_3,	64,	65},
    {L2S_Table11,	68,	-2},
    {isKey<']'>,	69,	105},
    {L2S_Table16,	70,	-2},
    {L2S_Table5,	72,	-8},
    {findPrime9_0_3,	73,	74},
    {isKey<','>,	78,	82},
    {isKey<ZIP_TOKEN(TID_LEX_Key)>,	79,	108},
    {L2S_Table19,	82,	-6},
    {L2S_Table12,	83,	-2},
    {isKey<']'>,	84,	111},
    {L2S_Table17,	85,	-2},
    {L2S_Table9,	86,	-8},
    {findPrime9_0_3,	88,	89},
    {L2S_Table2,	92,	-7},
    {L2S_Table13,	100,	-12},
    {L2S_Table6,	107,	-7},
    {L2S_Table10,	113,	-7},
    {findPrime10_0_7,	114,	117},
    {isKey<ZIP_TOKEN(TID_LEX_Num)>,	117,	124},
    {isKey<ZIP_TOKEN(TID_LEX_Num)>,	118,	125},
    {L2S_Table20,	120,	-11},
    {L2S_Table22,	123,	-3},
    {L2S_Table21,	126,	-10}};

void _reduce_1(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= # include $String
{
    const auto filename = dynamic_cast<C_ScannerParser&>(_paRSeR_).m_context.expand_include(bux::unlex<std::string>(_geT_(2)));
    _paRSeR_.reservePostShift([&,filename]{
            parseFile(filename, dynamic_cast<C_ScannerParser&>(_paRSeR_), '\n');
        }, 1);
}

void _reduce_2(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= % $Id <OptionValue>
{
    const auto &name = bux::unlex<std::string>(_geT_(1));
    auto &value = bux::unlex<C_StrList>(_geT_(2));
    dynamic_cast<C_ScannerParser&>(_paRSeR_).m_context.addOption(name, value);
}

void _reduce_3(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= $Id = <RegExpr> <LexResult>
{
    const auto &name = bux::unlex<std::string>(_geT_(0));
    auto &c = dynamic_cast<C_ScannerParser&>(_paRSeR_).m_context;
    if (c.eraseRE(name))
        _paRSeR_.onError(_geT_(0), "Duplicate regular expression name \""+name+"\"");
    auto &t = _geT_(2).m_attr;
    auto &val = dynamic_cast<C_NfaLex&>(*t);
    if (auto const action = bux::tryUnlex<C_WeightedStrList>(_geT_(3)))
    {
        action->m_1stFit = val.m_1stFit;
        val.m_NFA.setAction(std::move(*action));
    }
    c.addRE(name, val);
    t.disown(); // val (aka *t) has been taken as &val the pointer.
}

void _reduce_4(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionValue> ::= $Bracketed
//  <LexExpr> ::= <LexTerm>
{
    C_StrList t;
    t.emplace_back(bux::unlex<std::string>(_geT_(0)));
    _reT_ = bux::createLex(t);
}

void _reduce_5(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionValue> ::= <LexExpr>
//  <RegExpr> ::= <RegExprSeq>
//  <RegExprSeq> ::= <RegExprTerm>
//  <Integer> ::= $Num
//  <LexTerm> ::= $Operator
//  <LexTerm> ::= <@operator>
//  <LexTerm> ::= $Id
//  <LexTerm> ::= <@keyword>
{
     _reT_ = _geT_(0);
}

void _reduce_6(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExpr> ::= <RegExpr> | <RegExprSeq>
{
    auto        &dst = dynamic_cast<C_NfaLex&>(*_geT_(0));
    const auto  &src = dynamic_cast<C_NfaLex&>(*_geT_(2));
    dst.m_NFA |= src.m_NFA;
    dst.m_1stFit |= src.m_1stFit;
    _reT_ = _geT_(0);
}

void _reduce_7(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprSeq> ::= <RegExprSeq> <RegExprTerm>
{
    auto        &dst = dynamic_cast<C_NfaLex&>(*_geT_(0));
    const auto  &src = dynamic_cast<C_NfaLex&>(*_geT_(1));
    dst.m_NFA.append(src.m_NFA);
    dst.m_1stFit |=src.m_1stFit;
    _reT_ = _geT_(0);
}

void _reduce_8(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= ( <RegExpr> )
{
     _reT_ = _geT_(1);
}

void _reduce_9(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= { <RegExpr> }
{
    dynamic_cast<C_NfaLex&>(*_geT_(1)).m_NFA.changeTo(bux::FA_OPTIONAL);
    _reT_ = _geT_(1);
}

void _reduce_10(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $Id
{
    const auto &name = bux::unlex<std::string>(_geT_(0));
    if (const auto nfa = dynamic_cast<C_ScannerParser&>(_paRSeR_).m_context.findRE(name))
        // Clone an existing NFA
    {
        _reT_ = new C_NfaLex(*nfa);
        return;
    }
    _paRSeR_.onError(_geT_(0), "Unknown expression name \""+name+"\"");
    _reT_ = new C_NfaLex; // An idea to recover
}

void _reduce_11(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $String
{
    bux::C_NewNode<C_NfaLex> ret;
    for (auto i: bux::unlex<std::string>(_geT_(0)))
        ret->m_NFA.append(C_LexSet(i));

    _reT_ = ret;
}

void _reduce_12(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= $Key
{
    bux::C_NewNode<C_NfaLex> ret;
    ret->m_NFA.append(C_LexSet(bux::unlex<uint32_t>(_geT_(0))));
    _reT_ = ret;
}

void _reduce_13(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> *
{
    dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA.changeTo(bux::FA_REPEATABLE|bux::FA_OPTIONAL);
    _reT_ = _geT_(0);
}

void _reduce_14(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> +
{
    dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA.changeTo(bux::FA_REPEATABLE);
    _reT_ = _geT_(0);
}

void _reduce_15(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= <RegExprTerm> $Num
{
    switch (const auto n = dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).value<unsigned>())
    {
    case 0:
        _paRSeR_.onError(_geT_(1), "Zero repeat");
        break;
    case 1:
        break;
    default:
        auto &dst = dynamic_cast<C_NfaLex&>(*_geT_(0)).m_NFA;
        const auto addee{dst};
        for (unsigned i = 1; i < n; ++i)
            dst.append(addee);
    }
    _reT_ = _geT_(0);
}

void _reduce_16(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <RegExprTerm> ::= [ <BW_List> ]
//  <OptionalUBKey> ::= - $Key
//  <WithFinalCond> ::= @ <FinalCond>
//  <IfFinal> ::= if <LexExpr>
{
    _reT_ = _geT_(1);
}

void _reduce_17(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <BW_List> ::=
{
    bux::C_NewNode<C_NfaLex> ret;
    C_LexSet t;
    t.complement();
    ret->m_NFA.append(t);
    ret->m_1stFit = true;
    _reT_ = ret;
}

void _reduce_18(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <BW_List> ::= <SubCharSet>
{
    bux::C_NewNode<C_NfaLex> ret;
    ret->m_NFA.append(bux::unlex<C_LexSet>(_geT_(0)));
    _reT_ = ret;
}

void _reduce_19(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <BW_List> ::= ^ <OptionalSubCharSet>
{
    bux::C_NewNode<C_NfaLex> ret;
    if (auto src = bux::tryUnlex<C_LexSet>(_geT_(1)))
    {
        src->complement();
        ret->m_NFA.append(*src);
    }
    else
    {
        C_LexSet t;
        t.complement();
        ret->m_NFA.append(t);
        ret->m_1stFit = true;
    }
    _reT_ = ret;
}

void _reduce_20(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionalSubCharSet> ::= <SubCharSet>
//  <FinalCond> ::= <IfFinal>
//  <OptionalIfFinal> ::= <IfFinal>
{
    _reT_ = _geT_(0);
}

void _reduce_21(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= <SubCharSet> , <SubCharSet>
{
    bux::unlex<C_LexSet>(_geT_(0)) |= bux::unlex<C_LexSet>(_geT_(2));
    _reT_ = _geT_(0);
}

void _reduce_22(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $String
//  <SubCharSet> ::= $Id
{
    const auto t = bux::unlex<std::string>(_geT_(0));
    _reT_ = bux::createLex<C_LexSet>(t.begin(), t.end());
}

void _reduce_23(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Num
{
    const auto t = dynamic_cast<bux::C_IntegerLex&>(*_geT_(0)).str();
    _reT_ = bux::createLex<C_LexSet>(t.begin(), t.end());
}

void _reduce_24(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Key <OptionalUBKey>
{
    auto c1 = bux::unlex<uint32_t>(_geT_(0));
    if (auto c2 = bux::tryUnlex<uint32_t>(_geT_(1)))
    {
        if (c1 > *c2)
        {
            _paRSeR_.onError(_geT_(0), "Lower bound key is greater than upper bound key");
            const auto t = c1;
            c1 = *c2;
            *c2 = t;
        }
        _reT_ = bux::createLex<C_LexSet>(c1, *c2);
    }
    else
        _reT_ = bux::createLex<C_LexSet>(c1);
}

void _reduce_25(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <SubCharSet> ::= $Charset
{
    std::string s;
    if (auto errPos = spec2charset(bux::unlex<std::string>(_geT_(0)), s))
        // On error
    {
        const char *err;
        switch (errPos->second)
        {
        case SCE_INVALID_CHAR:          err = "Invalid char";       break;
        case SCE_MSSING_UB:             err = "Missing range UB";   break;
        case SCE_NOT_IN_SAME_GROUP:     err = "Not in same group";  break;
        case SCE_LB_GREATOR_THAN_UB:    err = "Range LB < UB";      break;
        default:                        err = "Unknown error";
        }
        auto pos = _geT_(0).m_pos;
        pos.m_Col += unsigned(errPos->first);
        _paRSeR_.onError(pos, err);
    }
    else
        // On success
        _reT_ = bux::createLex<C_LexSet>(s.begin(), s.end());
}

void _reduce_26(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexResult> ::= >> <LexExpr> <WithFinalCond>
{
    int w = 0;
    C_StrList *is_final = nullptr;
    auto &cond = _geT_(2).m_attr;
    if (!_geT_(2))
        ;
    else if (bux::C_IntegerLex *i = cond)
        w = i->value<int>();
    else if (auto f = bux::tryUnlex<C_StrList>(cond))
        is_final = f;
    else if (auto wf = bux::tryUnlex<std::pair<int,C_StrList>>(cond))
    {
        w = wf->first;
        is_final = &wf->second;
    }
    else
        _paRSeR_.onError(_geT_(2), "Unexpected <FinalCond> type "+HRTN(std::ref(*cond)));

    _reT_ = bux::createLex<C_WeightedStrList>(w, bux::unlex<C_StrList>(_geT_(1)), is_final);
}

void _reduce_27(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <FinalCond> ::= <Integer> <OptionalIfFinal>
{
    if (!_geT_(1))
        _reT_ = _geT_(0);
    else
        _reT_ = bux::createLex<std::pair<int,C_StrList>>(
                dynamic_cast<bux::C_IntegerLex&>(*_geT_(0)).value<int>(),
                std::move(bux::unlex<C_StrList>(_geT_(1))));
}

void _reduce_28(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Integer> ::= + $Num
{
    dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).prependPlus();
    _reT_ =_geT_(1);
}

void _reduce_29(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Integer> ::= - $Num
{
    dynamic_cast<bux::C_IntegerLex&>(*_geT_(1)).negate();
    _reT_ =_geT_(1);
}

void _reduce_30(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexExpr> ::= <LexExpr> <LexTerm>
{
    bux::unlex<C_StrList>(_geT_(0)).emplace_back(bux::unlex<std::string>(_geT_(1)));
    _reT_ = _geT_(0);
}

void _reduce_31(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexTerm> ::= $Num
{
    _reT_ = bux::createLex(' ' + dynamic_cast<bux::C_IntegerLex&>(*_geT_(0)).str());
}

void _reduce_32(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <LexTerm> ::= $Key
{
    _reT_ = bux::createLex('\'' + asciiLiteral(bux::unlex<uint32_t>(_geT_(0))) + '\'');
}

void _reduce_33(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@operator> ::= >>
{
    _reT_ = createLex<std::string>(">>");
}

void _reduce_34(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= if
{
    _reT_ = createLex<std::string>("if");
}

void _reduce_35(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= include
{
    _reT_ = createLex<std::string>("include");
}

struct C_ProductionInfo
{
    void            (*m_pAction)(bux::LR1::C_Parser&,const F_GetProduced&,C_RetLval);
    uint8_t         m_ReducedID;
    uint8_t         m_PopLength;
} constinit const prodInfo[58] ={
{nullptr,    	ZIP_TOKEN(NID_All),         1},	// 0: <All> ::= <Line>
{nullptr,    	ZIP_TOKEN(NID_All),         3},	// 1: <All> ::= <All> "\n" <Line>
{nullptr,    	ZIP_TOKEN(NID_Line),        0},	// 2: <Line> ::=
{_reduce_1, 	ZIP_TOKEN(NID_Line),        3},	// 3: <Line> ::= # include $String
{_reduce_2, 	ZIP_TOKEN(NID_Line),        3},	// 4: <Line> ::= % $Id <OptionValue>
{_reduce_3, 	ZIP_TOKEN(NID_Line),        4},	// 5: <Line> ::= $Id = <RegExpr> <LexResult>
{_reduce_4, 	ZIP_TOKEN(NID_OptionValue), 1},	// 6: <OptionValue> ::= $Bracketed
{_reduce_5, 	ZIP_TOKEN(NID_OptionValue), 1},	// 7: <OptionValue> ::= <LexExpr>
{_reduce_5, 	ZIP_TOKEN(NID_RegExpr),     1},	// 8: <RegExpr> ::= <RegExprSeq>
{_reduce_6, 	ZIP_TOKEN(NID_RegExpr),     3},	// 9: <RegExpr> ::= <RegExpr> | <RegExprSeq>
{_reduce_5, 	ZIP_TOKEN(NID_RegExprSeq),  1},	// 10: <RegExprSeq> ::= <RegExprTerm>
{_reduce_7, 	ZIP_TOKEN(NID_RegExprSeq),  2},	// 11: <RegExprSeq> ::= <RegExprSeq> <RegExprTerm>
{_reduce_8, 	ZIP_TOKEN(NID_RegExprTerm), 3},	// 12: <RegExprTerm> ::= ( <RegExpr> )
{_reduce_9, 	ZIP_TOKEN(NID_RegExprTerm), 3},	// 13: <RegExprTerm> ::= { <RegExpr> }
{_reduce_10,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 14: <RegExprTerm> ::= $Id
{_reduce_11,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 15: <RegExprTerm> ::= $String
{_reduce_12,	ZIP_TOKEN(NID_RegExprTerm), 1},	// 16: <RegExprTerm> ::= $Key
{_reduce_13,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 17: <RegExprTerm> ::= <RegExprTerm> *
{_reduce_14,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 18: <RegExprTerm> ::= <RegExprTerm> +
{_reduce_15,	ZIP_TOKEN(NID_RegExprTerm), 2},	// 19: <RegExprTerm> ::= <RegExprTerm> $Num
{_reduce_16,	ZIP_TOKEN(NID_RegExprTerm), 3},	// 20: <RegExprTerm> ::= [ <BW_List> ]
{_reduce_17,	ZIP_TOKEN(NID_BW_List),     0},	// 21: <BW_List> ::=
{_reduce_18,	ZIP_TOKEN(NID_BW_List),     1},	// 22: <BW_List> ::= <SubCharSet>
{_reduce_19,	ZIP_TOKEN(NID_BW_List),     2},	// 23: <BW_List> ::= ^ <OptionalSubCharSet>
{nullptr,    	ZIP_TOKEN(NID_OptionalSubCharSet), 0},	// 24: <OptionalSubCharSet> ::=
{_reduce_20,	ZIP_TOKEN(NID_OptionalSubCharSet), 1},	// 25: <OptionalSubCharSet> ::= <SubCharSet>
{_reduce_21,	ZIP_TOKEN(NID_SubCharSet),  3},	// 26: <SubCharSet> ::= <SubCharSet> , <SubCharSet>
{_reduce_22,	ZIP_TOKEN(NID_SubCharSet),  1},	// 27: <SubCharSet> ::= $String
{_reduce_22,	ZIP_TOKEN(NID_SubCharSet),  1},	// 28: <SubCharSet> ::= $Id
{_reduce_23,	ZIP_TOKEN(NID_SubCharSet),  1},	// 29: <SubCharSet> ::= $Num
{_reduce_24,	ZIP_TOKEN(NID_SubCharSet),  2},	// 30: <SubCharSet> ::= $Key <OptionalUBKey>
{_reduce_25,	ZIP_TOKEN(NID_SubCharSet),  1},	// 31: <SubCharSet> ::= $Charset
{nullptr,    	ZIP_TOKEN(NID_OptionalUBKey), 0},	// 32: <OptionalUBKey> ::=
{_reduce_16,	ZIP_TOKEN(NID_OptionalUBKey), 2},	// 33: <OptionalUBKey> ::= - $Key
{nullptr,    	ZIP_TOKEN(NID_LexResult),   0},	// 34: <LexResult> ::=
{_reduce_26,	ZIP_TOKEN(NID_LexResult),   3},	// 35: <LexResult> ::= >> <LexExpr> <WithFinalCond>
{nullptr,    	ZIP_TOKEN(NID_WithFinalCond), 0},	// 36: <WithFinalCond> ::=
{_reduce_16,	ZIP_TOKEN(NID_WithFinalCond), 2},	// 37: <WithFinalCond> ::= @ <FinalCond>
{_reduce_27,	ZIP_TOKEN(NID_FinalCond),   2},	// 38: <FinalCond> ::= <Integer> <OptionalIfFinal>
{_reduce_20,	ZIP_TOKEN(NID_FinalCond),   1},	// 39: <FinalCond> ::= <IfFinal>
{nullptr,    	ZIP_TOKEN(NID_OptionalIfFinal), 0},	// 40: <OptionalIfFinal> ::=
{_reduce_20,	ZIP_TOKEN(NID_OptionalIfFinal), 1},	// 41: <OptionalIfFinal> ::= <IfFinal>
{_reduce_16,	ZIP_TOKEN(NID_IfFinal),     2},	// 42: <IfFinal> ::= if <LexExpr>
{_reduce_5, 	ZIP_TOKEN(NID_Integer),     1},	// 43: <Integer> ::= $Num
{_reduce_28,	ZIP_TOKEN(NID_Integer),     2},	// 44: <Integer> ::= + $Num
{_reduce_29,	ZIP_TOKEN(NID_Integer),     2},	// 45: <Integer> ::= - $Num
{_reduce_4, 	ZIP_TOKEN(NID_LexExpr),     1},	// 46: <LexExpr> ::= <LexTerm>
{_reduce_30,	ZIP_TOKEN(NID_LexExpr),     2},	// 47: <LexExpr> ::= <LexExpr> <LexTerm>
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm),     1},	// 48: <LexTerm> ::= $Operator
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm),     1},	// 49: <LexTerm> ::= <@operator>
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm),     1},	// 50: <LexTerm> ::= $Id
{_reduce_5, 	ZIP_TOKEN(NID_LexTerm),     1},	// 51: <LexTerm> ::= <@keyword>
{_reduce_31,	ZIP_TOKEN(NID_LexTerm),     1},	// 52: <LexTerm> ::= $Num
{_reduce_32,	ZIP_TOKEN(NID_LexTerm),     1},	// 53: <LexTerm> ::= $Key
{nullptr,    	ZIP_TOKEN(bux::ROOT_NID),   1},	// 54: <@> ::= <All>
{_reduce_33,	ZIP_TOKEN(NIDa_operator),   1},	// 55: <@operator> ::= >>
{_reduce_34,	ZIP_TOKEN(NIDa_keyword),    1},	// 56: <@keyword> ::= if
{_reduce_35,	ZIP_TOKEN(NIDa_keyword),    1} 	// 57: <@keyword> ::= include
};

struct C_ActionTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&) { return static_cast<uint8_t>(t1); }
    static uint8_t valueError() { return ACTION_ERROR; }
};

struct C_ShiftTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&t2) { return static_cast<uint8_t>(t1+t2); }
    static uint8_t valueError() { RUNTIME_ERROR("SHIFT ERROR"); }
};

//
//   Generated Parser Policy
//
class C_ParserPolicy: public I_ParserPolicy
{
public:

    // Ctor
    C_ParserPolicy(): I_ParserPolicy(TOKENGEN_UB+2) {}

    // Implement I_ParserPolicy
    size_t action(bux::T_StateID state, bux::T_LexID token) const override;
    size_t getAcceptId() const override;
    bool getTokenName(bux::T_LexID token, std::string &name) const override;
    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;
    bool changeToken(bux::T_LexID &token, C_LexPtr &attr) const override;
    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;
    void onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, const std::string &message) const override;
}   g_policy;

size_t C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        return ACTION_ERROR;

    return index2value<uint8_t,uint8_t,int8_t,C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);
}

size_t C_ParserPolicy::getAcceptId() const
{
    return 54;
}

bool C_ParserPolicy::getTokenName(bux::T_LexID token, std::string &name) const
{
    static constinit char const *const NAMES[32] = {
        "$Bracketed",
        "$Charset",
        "$Epsilon",
        "$Id",
        "$Key",
        "$Num",
        "$Operator",
        "$Spaces",
        "$String",
        "\"if\"",
        "\"include\"",
        "\">>\"",
        "<All>",
        "<BW_List>",
        "<FinalCond>",
        "<IfFinal>",
        "<Integer>",
        "<LexExpr>",
        "<LexResult>",
        "<LexTerm>",
        "<Line>",
        "<OptionValue>",
        "<OptionalIfFinal>",
        "<OptionalSubCharSet>",
        "<OptionalUBKey>",
        "<RegExpr>",
        "<RegExprSeq>",
        "<RegExprTerm>",
        "<SubCharSet>",
        "<WithFinalCond>",
        "<@keyword>",
        "<@operator>"};
    if (bux::TOKENGEN_LB <= token && token < bux::TOKENGEN_LB + 32)
    {
        name = NAMES[token - bux::TOKENGEN_LB];
        return true;
    }
    return false;
}

bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        LOGIC_ERROR("Invalid input: state={} input={}", (int)state, printToken(input));

    auto end = mapGoto + 58;
    auto found = std::lower_bound(mapGoto, end, state, [](const C_MapGoto &i, bux::T_StateID state_) {
        return i.m_curState < state_;
    });
    if (found != end && found->m_curState == state)
        return index2value<uint8_t,uint8_t,int16_t,C_ShiftTraits>(found->m_k2v, found->m_nextStateEx, input);

    RUNTIME_ERROR("Invalid state: state={} input={}", (int)state, printToken(input));
}

bool C_ParserPolicy::changeToken(T_LexID &token, C_LexPtr &attr) const
{
    // User-defined %UPCAST_TOKEN begins
    if (isascii(token) && !iscntrl(token) && !isalnum(token) && !isspace(token))
    {
        attr.assign(bux::createLex<std::string>(1,char(token)), true);
        token = TID_LEX_Operator;
        return true;
    }
    return false;
    // User-defined %UPCAST_TOKEN ends
}

void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const
{
    const auto &src  = prodInfo[id];
    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB);
    info.m_PopLength = src.m_PopLength;
    info.m_Reduce    = src.m_pAction;
}

void C_ParserPolicy::onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, const std::string &message) const
{
    // User-defined %ON_ERROR begins
    dynamic_cast<C_ScannerParser&>(_paRSeR_).m_context.issueError(LL_ERROR, pos, message);
    // User-defined %ON_ERROR ends
}

} // namespace

const I_ParserPolicy &C_ScannerParser::policy()
{
    return g_policy;
}
