#include "Output.h"
#include "Cfa.h"                // C_GotoMap
//---------------------------------------------------------------------------
#include "bux/GLR.h"            // bux::GLR::ACTION_REDUCE_MIN
#include "bux/LR1.h"            // bux::LR1::ACTION_REDUCE_MIN
#include "bux/Range2Type.h"     // bux::fittestType()
#include "bux/ScannerBase.h"    // bux::isIdentifier()
#include "bux/XConsole.h"       // bux::testWritability()
#include <cctype>               // isascii(), isalnum()
#include <fstream>              // std::ofstream
#include <fmt/ostream.h>        // fmt::print() for std::ostream
#include <filesystem>           // std::filesystem::*
#include <iostream>             // std::cout

using namespace Main;
namespace fs = std::filesystem;

namespace {

//
//      In-Module Types
//
template<class T>
struct C_Range: std::pair<T,T>
{
    C_Range(): std::pair<T,T>(std::numeric_limits<T>::max(),std::numeric_limits<T>::min())
        {}
    void count(T t)
    {
        if (t < this->first)
            this->first =t;
        if (t > this->second)
            this->second =t;
    }
};

//
//      In-Module Functions
//
std::string alphaPrime(size_t ind)
{
    return "alphaPrime" + std::to_string(ind);
}

std::string L2A_Table(int ind)
{
    return "L2A_Table" + std::to_string(ind);
}

std::string L2S_Table(int ind)
{
    return "L2S_Table" + std::to_string(ind);
}

void setIndexedName(C_Strings &dst, size_t ind, const std::string &name)
{
    while (dst.size() <= ind)
        dst.emplace_back();

    dst[ind] = name;
}

int valueCount(const std::map<bux::T_LexID,C_Strings> &srcMap)
{
    size_t n{};
    for (auto &i: srcMap)
        n += i.second.size();

    return int(n);
}

void onUnmappedReduction(const std::set<std::string> &unmap, std::function<std::string()> funName)
{
    if (!unmap.empty())
    {
        std::string out{"Unmapped reduction variables within body of "+funName()};
        const char *delem = ": $";
        for (auto &i: unmap)
        {
            out.append(delem).append(i);
            delem = ", $";
        }
        RUNTIME_ERROR("{}", out);
    }
}

std::string trim(std::string s)
{
    auto pos = s.find_first_not_of(" \t\r\n");
    if (pos)
        s.erase(0, pos);

    pos = s.find_last_not_of(" \t\r\n");
    if (pos < s.size())
        s.erase(pos);

    return s;
}

} // namespace

class FC_Output::C_RenderReduction
{
public:

    // Types
    typedef std::pair<std::string,size_t> T_StrFtMask;

    // Nonvirtuals
    void addMap(const std::string &key, const std::string &value, size_t argMask);
    void addGetMap(size_t argInd);
    void clearMap();
    T_StrFtMask render(std::string src, std::set<std::string> &unmapped) const;

private:

    // Data
    std::map<std::string,T_StrFtMask>   m_replMap;
    std::optional<size_t>               m_getInd;
};

FC_Output::FC_Output        (
    const C_ParserInfo      &parsed,
    const C_GotoMap         &gotoMap,
    const C_ActionMap       &actionMap,
    const std::string       &grammarPath ):
    m_Parsed(parsed),
    m_ContextType(m_Parsed.contextType()),
    m_Banner(fmt::format(
        "// This file is fully generated by running " PROGNAME " v{}.{}.{}\n"
        "// with grammer definition file \"{}\"\n"
        "\n",
        VERSION_MAJOR,
        VERSION_MINOR,
        VERSION_RELEASE,
        grammarPath))
{
#ifdef __TEMPLATE_OUTPUT
    if (!parsed.templateArgs().empty())
    {
        m_TemplateParams = "template";
        bool first =true;
        for (auto &i: parsed.templateArgs())
        {
            m_TemplateParams += first? '<': ',';
            m_TemplateParams += i.m_TypeName.empty()? "class ": i.m_TypeName;
            m_TemplateParams += i.m_ArgDummy;

            m_ClassSuffix += first? '<': ',';
            m_ClassSuffix += i.m_ArgDummy;

            first = false;
        }
        m_TemplateParams += ">\n";
        m_ClassSuffix += '>';
    }
#endif // __TEMPLATE_OUTPUT

    size_t id =0;
    for (auto &i: m_Parsed.productions())
        m_ProdNums[&i] = id++;

    C_Range<T_LexID>        inputRan;
    C_Range<size_t>         stateRan, actionRan, poplenRan;
    C_Range<int>            iaTblSzRan, isTblSzRan;

    typedef std::map<size_t,C_Lex2State> C_State2istbl;
    C_State2istbl           state2is;

    for (auto &i: gotoMap)
    {
        const auto id = m_Parsed.prodTerm2id(i.first.second);
        if (m_lex2str.find(id) == m_lex2str.end())
            m_lex2str[id] = m_Parsed.outputId(i.first.second);

        if (id < MIN_TOKEN_ID)
            inputRan.count(id);

        state2is[i.first.first->m_id].emplace_back(id, i.second->m_id);
    }
    for (const auto &i: state2is)
        m_istbl2out[i.second];
    id =0;
    for (auto &i: m_istbl2out)
    {
        size_t lastState{};
        C_Alphabet curAlphas;
        bool stayInc = true;
        for (auto &j: i.first)
        {
            if (!curAlphas.empty() && lastState + 1 != j.second)
            {
                stayInc = false;
                break;
            }
            lastState = j.second;
            curAlphas.emplace_back(j.first);
        }
        if (!stayInc)
        {
            i.second.m_tableInd = int(id++);
            isTblSzRan.count(-int(i.first.size()));
        }
        else
        {
            i.second.m_tableInd = -1;
            if (curAlphas.size() > 1)
                m_alphaPrimes.add(curAlphas);
        }
    }

    m_MinTokenId = inputRan.second +1;
    inputRan.count(T_LexID(
                   bux::TOKENGEN_LB
                 + m_Parsed.lex2ID().size()
                 + m_Parsed.generatedLexes().size()
                 + m_Parsed.nonterminals().size()
                 + 1 - (bux::MIN_TOKEN_ID - m_MinTokenId)));

    id = 0; // as current state
    std::set<const C_IndexedProd*> actionIdSrc;
    for (auto &i: actionMap)
    {
        const auto &value = i.second;
        if (id != i.first || value.empty())
        {
            fmt::print("Unexpected action-less state {}\n", id);
            m_readySoFar = false;
            return;
        }
        for (auto &j: value)
            for (auto k: j.second.m_reduces)
            {
                actionIdSrc.insert(k);
                poplenRan.count(k->m_Rval.size());
            }
        m_iatbl2out[value];
        ++id;
    }
    stateRan.count(id-1);
    id = 0; // as new idtable id
    for (auto &i: m_iatbl2out)
    {
        std::string lastAction;
        bool sameAction = true;
        C_Alphabet curAlphas;
        for (auto &j: i.first)
        {
            const auto id = m_Parsed.prodTerm2id(j.first);
            if (id < MIN_TOKEN_ID)
                inputRan.count(id);
            if (m_lex2str.find(id) == m_lex2str.end())
                m_lex2str[id] = m_Parsed.outputId(j.first);

            auto &actions = i.second.m_outMapping[id];
            if (j.second.m_hasAccept)
                actions.emplace_back("ACTION_ACCEPT");
            if (j.second.m_hasShift)
                actions.emplace_back("ACTION_SHIFT");
            for (auto k: j.second.m_reduces)
                actions.emplace_back("ACTION_REDUCE_MIN + " + std::to_string(serial(k)));

            curAlphas.emplace_back(id);
            for (auto &k: actions)
            {
                if (lastAction.empty())
                    lastAction = k;
                else if (lastAction != k)
                    sameAction = false;
            }
            if (actions.size() > 1)
            {
                if (!m_Parsed.getOption("SUPPRESS_GLR_CONFLICTS"))
                {
                    std::string names;
                    for (auto &k: actions)
                    {
                        if (!names.empty())
                            names += ", ";

                        names += k;
                    }
                    fmt::print("GLR needed for lex {} conflics on: {}\n", m_lex2str.find(id)->second, names);
                }
                m_needGLR = true;
            }
        }
        if (!sameAction)
        {
            if (i.first.size() != i.second.m_outMapping.size())
            {
                fmt::print("Size changed {} != {}\n", i.first.size(), i.second.m_outMapping.size());
                m_readySoFar = false;
                return;
            }
            i.second.m_iaTableInd = int(id++);
            iaTblSzRan.count(-valueCount(i.second.m_outMapping));
        }
        else
        {
            i.second.m_iaTableInd = -1; // The output table is optimized away
            if (curAlphas.size() > 1)
                m_alphaPrimes.add(curAlphas);
        }
    } // for (auto &i: m_iatbl2out)

    const auto reduceMin = m_needGLR?
        size_t(bux::GLR::ACTION_REDUCE_MIN):
        size_t(bux::LR1::ACTION_REDUCE_MIN);
    for (auto i: actionIdSrc)
        actionRan.count(serial(i) + reduceMin);

    iaTblSzRan.count(int(actionRan.second));
    isTblSzRan.count(int(stateRan.second));
    m_StateType     = bux::fittestType(stateRan.first, stateRan.second);
    m_InputType     = bux::fittestType(inputRan.first, inputRan.second);
    m_ActionType    = bux::fittestType(actionRan.first, actionRan.second);
    m_PoplenType    = bux::fittestType(poplenRan.first, poplenRan.second);
    m_iaTblSzType   = bux::fittestType(iaTblSzRan.first, iaTblSzRan.second);
    m_isTblSzType   = bux::fittestType(isTblSzRan.first, isTblSzRan.second);
    for (auto &i: actionMap)
    {
        const auto &output = m_iatbl2out.find(i.second)->second;
        if (output.m_iaTableInd >= 0)
            m_state2iatbl.emplace_back(L2A_Table(output.m_iaTableInd), std::to_string(-valueCount(output.m_outMapping)));
        else
        {
            std::string ptrStr;
            const auto iMapping1st = output.m_outMapping.begin();
            if (1 == i.second.size())
                ptrStr = outputIsKey(iMapping1st->first);
            else
            {
                C_Alphabet alphabet;
                for (auto &j: output.m_outMapping)
                    alphabet.emplace_back(j.first);

                ptrStr = outputFindKey(alphabet);
            }
            m_state2iatbl.emplace_back(ptrStr, iMapping1st->second.front());
        }
    }
    for (const auto &i: state2is)
    {
        auto &dst = m_state2next[i.first];

        const auto &output = m_istbl2out.find(i.second)->second;
        const int tblSize = int(i.second.size());
        if (output.m_tableInd >= 0)
        {
            dst.first = L2S_Table(output.m_tableInd);
            dst.second = std::to_string(-tblSize);
        }
        else
        {
            std::string ptrStr;
            if (1 == tblSize)
                ptrStr = outputIsKey(i.second.front().first);
            else
            {
                C_Alphabet alphabet;
                for (auto &j: i.second)
                    alphabet.emplace_back(j.first);

                ptrStr = outputFindKey(alphabet);
            }
            dst.first = ptrStr;
            dst.second = std::to_string(i.second.front().second);
        }
    }
}

bool FC_Output::operator()(const char *outputPath, const char *tokenPath, int flags) const
{
    if (!m_readySoFar)
        return false;

    //
    //      Get base name
    //
    fs::path path(outputPath);
    const auto base = path.stem().generic_string();
    const auto className = [this,&base]{
        auto ret = m_Parsed.className();
        if (ret.empty())
        {
            ret = "C_";
            for (auto c: base)
                ret += isascii(c) && isalnum(c)? c: '_';
        }
        return ret;
    }();
    const auto      headClassName = m_Parsed.fullNamespace()+"::"+className;
    C_Strings       tokenStrs;
    size_t          maxWidth;
    bux::T_LexID    tid_ub = bux::TOKENGEN_LB;  // initialized as
    if (!m_Parsed.generatedLexes().empty())
        tid_ub = m_Parsed.generatedLexes().crbegin()->second + 1;

    //
    //      Output ID def header
    //
    path.replace_extension() += "IdDef.h";
    if (!(flags & ALWAYS_OVERWRITE) && !bux::testWritability(path.c_str()))
        return false;
    std::ofstream   out{path};
    if (!out.is_open())
    {
        fmt::print("Write error on {}\n", path.generic_string());
        return false;
    }
    static const auto U8BOM = reinterpret_cast<const char*>(u8"\ufeff");
    if (flags & WITH_BOM)
        out.write(U8BOM, 3);

    out <<m_Banner;
    if (auto found =m_Parsed.getOption("IDDEF_SOURCE"))
    {
        fmt::print(out, "#include \"{}\"\n", found->expand());
        for (auto &i: m_Parsed.lex2ID())
            setIndexedName(tokenStrs, i.second - bux::TOKENGEN_LB, '$' + i.first);

        for (auto &i: m_Parsed.generatedLexes())
        {
            for (auto &j: m_Parsed.literalMap())
                if (j.second == i.first)
                {
                    setIndexedName(tokenStrs, i.second - bux::TOKENGEN_LB, j.first);
                    break;
                }
        }
    }
    else
    {
        out <<"#pragma once\n"
              "\n"
              "#include <bux/LexBase.h>    // bux::TOKENGEN_LB\n";
        if (!m_Parsed.idSet())
        {
            fmt::print("Yet to set id values of m_Parsed.lex2ID() & m_Parsed.geneTokens()\n");
            return false;
        }
        m_Parsed.enterNamespaces(out);
        out <<"\n"
              "// Token Id Constants\n"
              "enum\n"
              "{\n";
        maxWidth = 0;
        for (auto &i: m_Parsed.lex2ID())
        {
            const size_t n =i.first.size();
            if (maxWidth < n)
                maxWidth = n;
        }
        if (maxWidth)
            maxWidth += 8; // Length of "TID_LEX_"

        for (auto &i: m_Parsed.generatedLexes())
        {
            const size_t n = i.first.size();
            if (maxWidth < n)
                maxWidth = n;
        }
        if (size_t n = (maxWidth + 1) % 4)
            maxWidth += 4 - n;

        for (auto &i: m_Parsed.lex2ID())
        {
            auto s = "TID_LEX_" + i.first;
            if (s.size() < maxWidth)
                s.append(maxWidth-s.size(), ' ');

            const size_t ind = i.second - bux::TOKENGEN_LB;
            out <<"    " <<s <<" = bux::TOKENGEN_LB+" <<ind <<",\t// $" <<i.first <<'\n';
            setIndexedName(tokenStrs, ind, '$'+i.first);
        }

        for (auto &i: m_Parsed.generatedLexes())
        {
            auto s = i.first;
            if (s.size() < maxWidth)
                s.append(maxWidth-s.size(), ' ');

            const size_t ind = i.second - bux::TOKENGEN_LB;
            out <<"    " <<s <<" = bux::TOKENGEN_LB+" <<ind <<',';
            for (auto &j: m_Parsed.literalMap())
                if (j.second == i.first)
                {
                    std::string name(asciiLiteral(j.first));
                    name.insert(0,"\"") += '"';
                    setIndexedName(tokenStrs, ind, name);
                    out <<"\t// " <<name;
                    break;
                }
            out <<'\n';
        }
        out <<(m_Parsed.nonterminals().empty()?
               "    TOKENGEN_UB":
               "    TID_UB_");
        if (m_Parsed.lex2ID().empty() && m_Parsed.generatedLexes().empty())
            out <<" = bux::TOKENGEN_LB";

        out <<"\n"
              "};\n";
        m_Parsed.leaveNamespaces(out);
    }
    out.close();

    //
    //      Output scanner-specific inputs
    //
    if (tokenPath)
    {
        std::ofstream out(tokenPath);
        if (flags & WITH_BOM)
            out.write(U8BOM, 3);

        outputTokens(out, base);
    }
    else
        outputTokens(std::cout, base);

    //
    //      Output .h file
    //
    path = outputPath;
    path.replace_extension(".h");
    if (!(flags & ALWAYS_OVERWRITE) && !bux::testWritability(path.c_str()))
        return false;
    out.open(path);
    if (!out.is_open())
    {
        fmt::print("Write error on {}\n", path.generic_string());
        return false;
    }
    if (flags & WITH_BOM)
        out.write(U8BOM, 3);

    const char *const nsLR = m_needGLR? "GLR": "LR1";
    fmt::print(out,
        "{0}"
        "#pragma once\n"
        "\n"
        "#include <bux/{1}.h>\n", m_Banner, nsLR);
    writeUserSection(out, "HEADERS_FOR_HEADER");
    m_Parsed.enterNamespaces(out);
    writeUserSection(out, "PRECLASSDECL");
    fmt::print(out,
        "\n"
        "class {}: public bux::{}::C_Parser\n"
        "{{\n"
        "public:\n"
        "\n", className, nsLR);
    if (hasContext())
    {
        if (!m_needGLR)
            // LR1
            fmt::print(out,
                "    // Data\n"
                "    {:23} m_context;\n" // m_context will be at column 28 if context.size() <= 23
                "\n", m_ContextType);
        else
            // GLR
            fmt::print(out,
                "    // Type\n"
                "    using C_Context = std::remove_reference_t<{}>;\n"
                "\n", m_ContextType);
    }
    out <<"    // Ctor\n";
    if (!hasContext())
        // Have no context
        fmt::print(out, "    {}();\n", className);
    else
    {
        if (m_needGLR)
            // GLR
            fmt::print(out,
                "    {0}(C_Context &context): {0}() {{ userData(&context); }}\n"
                "\n"
                "private:\n"
                "\n"
                "    {0}();\n", className);
        else
            // LR1
            fmt::print(out,
                "    template<class...T_Args>\n"
                "    {0}(T_Args&&...args): bux::{1}::C_Parser(policy()), m_context(std::forward<T_Args>(args)...) {{}}\n"
                "\n"
                "private:\n"
                "\n"
                "    static const bux::{1}::I_ParserPolicy &policy();\n",
                className, nsLR);
    }
    writeUserSection(out, "INCLASSDECL");
    out <<"};\n";
    m_Parsed.leaveNamespaces(out);
    out.close();

    //
    //      Output .cpp file
    //
    path = outputPath;
    path.replace_extension(".cpp");
    if (!(flags & ALWAYS_OVERWRITE) && !bux::testWritability(path.c_str()))
        return false;
    out.open(path);
    if (!out.is_open())
    {
        fmt::print("Write error on {}\n", path.generic_string());
        return false;
    }
    if (flags & WITH_BOM)
        out.write(U8BOM, 3);

    out <<m_Banner;
    writeUserSection(out, "HEADERS_FOR_CPP");
    fmt::print(out,
        "#include \"{0}.h\"\n"
        "#include \"{0}IdDef.h\"\n"
        "#include <bux/Impl{1}.h>\n"
        "#include <bux/XException.h>\n"
        "\n"
        "namespace {{\n"
        "\n"
        "using namespace bux::{1};\n",
        base, nsLR);
    const auto targetNS = m_Parsed.fullNamespace();
    if (!targetNS.empty())
        fmt::print(out, "using namespace {};\n", targetNS);

    writeUserSection(out, "LOCAL_CPP");
    out <<"\n"
          "//\n"
          "//   Generated Constants\n"
          "//\n"
          "enum\n"
          "{\n";
    if (!m_Parsed.nonterminals().empty())
    {
        maxWidth = 0;
        for (auto &i: m_Parsed.nonterminals())
        {
            const size_t n = i.first.size();
            if (maxWidth < n)
                maxWidth = n;
        }
        for (auto &i: m_Parsed.nonterminals())
        {
            auto s = i.first;
            if (s.size() < maxWidth)
                s.append(maxWidth-s.size(), ' ');

            fmt::print(out, "    {} = TID_UB_+{},", s, i.second-tid_ub);
            std::string name;
            if (!memcmp(i.first.data(), "NID_", 4))
                name = '<' + i.first.substr(4) + '>';
            if (!memcmp(i.first.data(), "NIDa_", 5))
                name = "<@" + i.first.substr(5) + '>';
            if (!name.empty())
            {
                setIndexedName(tokenStrs, i.second - bux::TOKENGEN_LB, name);
                out <<"\t// " <<name;
            }
            out <<'\n';
        }

        out <<"    TOKENGEN_UB,\n"
              "    //---------------------------------------------------\n";
    }
    fmt::print(out,
        "    " ENCODED_TOKEN_LB_str "\t = {}\n"
        "}};\n"
        "constexpr auto ZIP_TOKEN(auto x) {{ return x-(bux::MIN_TOKEN_ID-" ENCODED_TOKEN_LB_str "); }}\n"
        "\n", m_MinTokenId);
    if (!m_alphaPrimes.empty())
    {
        fmt::print(out, "constinit const {}\n", m_InputType);
        bool first = true;
        m_alphaPrimes.visit([&](const C_Alphabet &belt, size_t ind){
            if (first)
                first = false;
            else
                out <<",\n";

            fmt::print(out, "{}[{}] = ", alphaPrime(ind), belt.size());
            bool first = true;
            for (auto j: belt)
            {
                out <<(first? '{': ',') <<"\n"
                      "    " <<m_lex2str.find(j)->second;
                first = false;
            }
            out <<'}';
        });
        out <<";\n"
              "\n";
    }
    if (m_isKeyCalled)
        fmt::print(out,
            "template<{0} KEY> int isKey({0} key)\n"
            "{{\n"
            "    return key == KEY? 0: -1;\n"
            "}}\n"
            "\n", m_InputType);
    if (!m_findPrimes.empty())
    {
        fmt::print(out,
            "int findKey(const {0} *klist, int n, {0} key)\n"
            "{{\n"
            "    for (int i = 0; i < n; ++i)\n"
            "         if (key == klist[i])\n"
            "             return i;\n"
            "    return -1;\n"
            "}}\n"
            "\n", m_InputType);
        for (const auto &i: m_findPrimes)
            fmt::print(out, "int {}\t({} key)\t{{ {} }}\n", i.first, m_InputType, i.second);

        out <<'\n';
    }
    bool first = true;
    for (auto &i: m_iatbl2out)
        if (i.second.m_iaTableInd >= 0)
        {
            if (first)
            {
                fmt::print(out, "constinit const bux::C_KVPair<{},{}>\n", m_InputType, m_ActionType);
                first = false;
            }
            else
                out <<",\n";

            out <<L2A_Table(i.second.m_iaTableInd) <<"[] =";
            bool first = true;
            for (auto &j: i.second.m_outMapping)
            {
                const auto input = m_lex2str.find(j.first)->second;
                for (auto &k: j.second)
                {
                    fmt::print(out, "{}\n"
                        "    {{{},\t{}}}", (first?'{':','), input, k);
                    first = false;
                }
            }
            out <<'}';
        }
    if (!first)
        out <<";\n"
              "\n";
    if (!m_state2iatbl.empty())
    {
        fmt::print(out, "constinit const bux::U_K2V<{},{}> mapActionPtr[{}] =",
            m_InputType, m_ActionType, m_state2iatbl.size());
        std::string restOfLine;
        int n = 0;
        for (auto &i: m_state2iatbl)
        {
            out <<(n? ',': '{') <<restOfLine <<"\n"
                  "    " <<i.first;
            restOfLine = "\t// " + std::to_string(n++);
        }
        fmt::print(out,
            "}};{}\n"
            "\n"
            "constinit const {} mapActionSizeEx[{}] =", restOfLine, m_iaTblSzType, m_state2iatbl.size());
        n =0;
        restOfLine.clear();
        for (auto &i: m_state2iatbl)
        {
            out <<(n? ',': '{') <<restOfLine <<"\n"
                  "    " <<i.second;
            restOfLine = "\t// " + std::to_string(n++);
        }
        fmt::print(out,
            "}};{}\n"
            "\n", restOfLine);
    }
    first = true;
    for (auto &i: m_istbl2out)
        if (i.second.m_tableInd >= 0)
        {
            if (first)
            {
                first = false;
                fmt::print(out, "constinit const bux::C_KVPair<{},{}>\n", m_InputType, m_StateType);
            }
            else
                out <<",\n";

            out <<L2S_Table(i.second.m_tableInd) <<"[] =";
            bool first = true;
            for (auto &j: i.first)
            {
                fmt::print(out,
                    "{}\n"
                    "    {{{},\t{}}}",
                    (first?'{':','), m_lex2str.find(j.first)->second, j.second);
                first = false;
            }
            out <<'}';
        }
    if (!first)
        out <<";\n"
              "\n";

    if (!m_state2next.empty())
    {
        fmt::print(out,
            "constinit const struct C_MapGoto {{\n"
            "    bux::U_K2V<{},{}> m_k2v;\n"
            "    {}\tm_curState;\n"
            "    {}\tm_nextStateEx;\n"
            "}}   mapGoto[{}] =",
            m_InputType, m_ActionType, m_StateType, m_isTblSzType, m_state2next.size());
        first = true;
        for (auto &i: m_state2next)
        {
            fmt::print(out,
                "{}\n"
                "    {{{},\t{},\t{}}}",
                (first?'{':','), i.second.first, i.first, i.second.second);
            first = false;
        }
        out <<"};\n"
              "\n";
    }
    std::set<size_t> nullReducers;
    C_RenderReduction rr;
    addParserMap(rr, headClassName, 0);
    rr.addGetMap(1);
    rr.addMap("r", ARG_NAME_RESULT, 1<<2);
    if (m_needGLR)
        rr.addMap("postShift", "postShift", 1<<3);

    for (size_t i = 0; const auto r = m_Parsed.getReduction(i); ++i)
    {
        std::set<std::string> unmap;
        const auto ret = rr.render(*r, unmap);
        if (ret.first.empty() || ret.first.find_first_not_of(" \t\r\n") == std::string::npos)
        {
            nullReducers.insert(i);
            continue;
        }

        fmt::print(out, "void _reduce_{}(bux::{}::C_Parser &", i, nsLR);
        if (ret.second & (1<<0))
            out <<ARG_NAME_PARSER;

        out <<", const F_GetProduced &";
        if (ret.second & (1<<1))
            out <<ARG_NAME_GETLEX;

        out <<", C_RetLval ";
        if (ret.second & (1<<2))
            out <<ARG_NAME_RESULT;

        if (m_needGLR)
       {
            out <<", F_OncePostShift &";
            if (ret.second & (1<<3))
                out <<"postShift";
        }

        out <<")\n";
        std::string prodStr;
        for (auto &j: m_Parsed.productions())
        {
            if (j.m_Index == i)
            {
                prodStr = j.str();
                out <<"//  " <<prodStr <<'\n';
            }
        }
        out <<"{\n"
            <<ensureNoConcat(ret.first)
            <<"}\n"
              "\n";
        onUnmappedReduction(unmap, [&]{
            return "production "+prodStr;
        });
    }
    fmt::print(out,
        "struct C_ProductionInfo\n"
        "{{\n"
        "    {:15} (*m_pAction)(bux::{}::C_Parser&,const F_GetProduced&,C_RetLval{});\n"
        "    {:15} m_ReducedID;\n"
        "    {:15} m_PopLength;\n"
        "}} constinit const prodInfo[{}] =",
        "void", nsLR, m_needGLR?",F_OncePostShift&":"",
        m_InputType, m_PoplenType, m_Parsed.productions().size());
    size_t maxLvalLen =0;
    for (auto &i: m_Parsed.productions())
    {
        if (maxLvalLen < i.m_Lval.size())
            maxLvalLen =i.m_Lval.size();
    }
    maxLvalLen +=7 +3;
    maxLvalLen -=maxLvalLen %4;
    int acceptID =-1;
    std::string restOfLine;
    first =true;
    for (auto &i: m_Parsed.productions())
    {
        out <<(first? '{': ',') <<restOfLine <<"\n";
        const size_t reduceInd = m_Parsed.getReductionIndex(i);
        if (nullReducers.contains(reduceInd))
            out <<"{nullptr,    \t";
        else
            out <<"{_reduce_" <<reduceInd <<(reduceInd < 10? ", \t": ",\t");

        std::string input;
        const size_t prodNum = serial(&i);
        std::string nid;
        if (getNonterminalID(i.m_Lval, nid))
            input ="ZIP_TOKEN(" +nid +"),";
        else
        {
            input = "ZIP_TOKEN(bux::ROOT_NID),";
            acceptID = int(prodNum);
        }

        if (maxLvalLen > input.size())
            input.append(maxLvalLen-input.size(), ' ');
        else
            input +=' ';

        out <<input <<i.m_Rval.size() <<"}";
        restOfLine = fmt::format("\t// {}: {}", prodNum, i.str());
        first = false;
    }
    if (acceptID < 0)
        RUNTIME_ERROR("Accept id: {}", acceptID);

    fmt::print(out,
        " {0}\n"
        "}};\n"
        "\n"
        "struct C_ActionTraits\n"
        "{{\n"
        "    template<class T1, class T2>\n"
        "    static {1} map(T1 &&t1, T2 &&) {{ return static_cast<{1}>(t1); }}\n",
        restOfLine, m_ActionType);
    if (!m_needGLR)
          out <<"    static " <<m_ActionType <<" valueError() { return ACTION_ERROR; }\n";

    out <<"};\n"
          "\n";
    if (!m_state2next.empty())
        fmt::print(out,
            "struct C_ShiftTraits\n"
            "{{\n"
            "    template<class T1, class T2>\n"
            "    static {0} map(T1 &&t1, T2 &&t2) {{ return static_cast<{0}>(t1+t2); }}\n"
            "    static {0} valueError() {{ RUNTIME_ERROR(\"SHIFT ERROR\"); }}\n"
            "}};\n"
            "\n", m_StateType);

    out <<"//\n"
          "//   Generated Parser Policy\n"
          "//\n"
          "class C_ParserPolicy: public I_ParserPolicy\n"
          "{\n"
          "public:\n";

    if (!m_needGLR)
    {
        out <<"\n"
              "    // Ctor\n"
              "    C_ParserPolicy(): I_ParserPolicy(";
        std::string errId;
        if (const auto found = m_Parsed.getOption("ERROR_TOKEN"))
        {
            errId = trim(found->expand());
            if (errId.empty())
                errId = "Error";
            else if (!bux::isIdentifier(errId))
                RUNTIME_ERROR("Value of %ERROR_TOKEN is not identifier: {}", errId);

            if (m_Parsed.lex2ID().find(errId) != m_Parsed.lex2ID().end())
                // Found
                errId = "TID_LEX_" + errId;
            else
                errId.clear();
        }
        out <<(errId.empty()?"TOKENGEN_UB+2":errId) <<") {}\n";
    }
    const char *const actionRet = m_needGLR? "std::vector<T_ActionId>": "size_t";
    out <<"\n"
          "    // Implement I_ParserPolicy\n"
          "    " <<actionRet <<" action(bux::T_StateID state, bux::T_LexID token) const override;\n"
          "    size_t getAcceptId() const override;\n";
    bool hasGetTokenName = false;
    if (!tokenStrs.empty())
    {
        out <<"    bool getTokenName(bux::T_LexID token, std::string &name) const override;\n";
        hasGetTokenName = true;
    }
    out <<"    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;\n";
    const auto foundUpcastToken = m_Parsed.getOption("UPCAST_TOKEN");
    if (foundUpcastToken)
        out <<"    bool changeToken(bux::T_LexID &token, C_LexPtr &attr) const override;\n";

    using namespace std::literals;
    const auto parserArgType = "bux::"s+nsLR+"::C_Parser &";
    out <<"    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;\n"
          "    void onError(" <<parserArgType <<ARG_NAME_PARSER ", const bux::C_SourcePos &pos, std::string_view message) const override;\n"
          "}   g_policy;\n"
          "\n"
        <<actionRet <<" C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const\n"
          "{\n"
          "    if (input >= bux::MIN_TOKEN_ID)\n"
          "        input = ZIP_TOKEN(input);\n"
          "    else if (input >= " ENCODED_TOKEN_LB_str ")\n"
          "        return " <<(m_needGLR?"{}":"ACTION_ERROR") <<";\n"
          "\n"
        <<(m_needGLR?
          "    auto t = index2values":
          "    return index2value")
        <<'<' <<m_InputType <<',' <<m_ActionType <<',' <<m_iaTblSzType <<",C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);\n";
    if (m_needGLR)
        out <<"    return {t.begin(), t.end()};\n";

    out <<"}\n"
          "\n"
          "size_t C_ParserPolicy::getAcceptId() const\n"
          "{\n"
          "    return " <<acceptID <<";\n"
          "}\n"
          "\n";
    if (hasGetTokenName)
    {
        out <<"bool C_ParserPolicy::getTokenName(bux::T_LexID token, std::string &name) const\n"
              "{\n";
        size_t nullCount = 0;
        for (auto &i: tokenStrs)
            if (i.empty())
                ++nullCount;

        if (nullCount * 2 <= tokenStrs.size())
            // Majority Case
        {
            out <<"    static constinit char const *const NAMES[" <<tokenStrs.size() <<"] = ";
            first = true;
            for (auto &i: tokenStrs)
            {
                out <<(first? '{': ',') <<"\n"
                      "        ";
                if (i.empty())
                    out <<"nullptr";
                else
                    out <<'"' <<bux::asciiLiteral(i) <<'"';

                first = false;
            }
            out <<"};\n"
                  "    if (bux::TOKENGEN_LB <= token && token < bux::TOKENGEN_LB + " <<tokenStrs.size() <<")\n"
                  "    {\n"
                <<(nullCount?
                  "        if (auto p = NAMES[token - bux::TOKENGEN_LB])\n"
                  "        {\n"
                  "            name = p;\n"
                  "            return true;\n"
                  "        }\n":
                  "        name = NAMES[token - bux::TOKENGEN_LB];\n"
                  "        return true;\n")
                <<"    }\n";
        }
        else
            // Null Majority
        {
            out <<"    static constinit const struct\n"
                  "    {\n"
                  "        bux::T_LexID     m_key;\n"
                  "        const char       *m_value;\n"
                  "    }   MAP[] = ";
            first = true;
            for (size_t i = 0, n = tokenStrs.size(); i < n; ++i)
            {
                const auto s = tokenStrs[i];
                if (!s.empty())
                {
                    out <<(first? '{': ',') <<"\n"
                          "        {bux::TOKENGEN_LB+" <<i <<", \"" <<bux::asciiLiteral(s) <<"\"}";
                    first = false;
                }
            }
            out <<"},\n"
                  "        *const ENDOMAP = MAP + sizeof(MAP)/sizeof(*MAP);\n"
                  "\n"
                  "    for (auto i = MAP; i < ENDOMAP; ++i)\n"
                  "        if (i->m_key == token)\n"
                  "        {\n"
                  "            name = i->m_value;\n"
                  "            return true;\n"
                  "        }\n"
                  "\n";
        }
        out <<"    return false;\n"
              "}\n"
              "\n";
    }
    out <<"bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const\n"
          "{\n";
    if (m_state2next.empty())
        out <<"    // Empty mapGoto[]\n";
    else
        out <<"    if (input >= bux::MIN_TOKEN_ID)\n"
              "        input = ZIP_TOKEN(input);\n"
              "    else if (input >= " ENCODED_TOKEN_LB_str ")\n"
              "        LOGIC_ERROR(\"Invalid input: state={} input={}\", (int)state, printToken(input));\n"
              "\n"
              "    auto end = mapGoto + " <<m_state2next.size() <<";\n"
              "    auto found = std::lower_bound(mapGoto, end, state, [](const C_MapGoto &i, bux::T_StateID state_) {\n"
              "        return i.m_curState < state_;\n"
              "    });\n"
              "    if (found != end && found->m_curState == state)\n"
              "        return index2value<" <<m_InputType <<',' <<m_StateType <<',' <<m_isTblSzType
            <<",C_ShiftTraits>(found->m_k2v, found->m_nextStateEx, input);\n"
              "\n";

    out <<"    RUNTIME_ERROR(\"Invalid state: state={} input={}\", (int)state, printToken(input));\n"
          "}\n";
    if (foundUpcastToken)
    {
        rr.clearMap();
        rr.addMap("token", "token", 1<<0);
        rr.addMap("attr", "attr", 1<<1);
        std::set<std::string> unmap;
        const auto ret = rr.render(ensureNoConcat(*foundUpcastToken), unmap);
        out <<"\n"
              "bool C_ParserPolicy::changeToken(T_LexID &";
        if (ret.second & (1<<0))
            out <<"token";

        out <<", C_LexPtr &";
        if (ret.second & (1<<1))
            out <<"attr";

        out <<") const\n"
             "{\n"
              "    // Grammar %UPCAST_TOKEN begins\n"
            <<ret.first
            <<"    // Grammar %UPCAST_TOKEN ends\n"
              "}\n";
        onUnmappedReduction(unmap, [&]{
            return "C_ParserPolicy::changeToken()";
        });
    }
    out <<"\n"
          "void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const\n"
          "{\n"
          "    const auto &src  = prodInfo[id];\n"
          "    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-" ENCODED_TOKEN_LB_str ");\n"
          "    info.m_PopLength = src.m_PopLength;\n"
          "    info.m_Reduce    = src.m_pAction;\n"
          "}\n";
    const auto foundOnError = m_Parsed.getOption("ON_ERROR");
    if (foundOnError)
    {
        rr.clearMap();
        addParserMap(rr, headClassName, 0);
        rr.addMap("pos", "pos", 1<<1);
        rr.addMap("message", "message", 1<<2);
        std::set<std::string> unmap;
        const auto ret = rr.render(ensureNoConcat(*foundOnError), unmap);
        out <<"\n"
              "void C_ParserPolicy::onError(" <<parserArgType;
        if (ret.second & (1<<0))
            out <<ARG_NAME_PARSER;

        out <<", const bux::C_SourcePos &";
        if (ret.second & (1<<1))
            out <<"pos";

        out <<", std::string_view ";
        if (ret.second & (1<<2))
            out <<"message";

        out <<") const\n"
              "{\n"
              "    // Grammar %ON_ERROR begins\n"
            <<ret.first
            <<"    // Grammar %ON_ERROR ends\n"
              "}\n";
        onUnmappedReduction(unmap, [&]{
            return "C_ParserPolicy::onError()";
        });
    }
    else
        out <<"\n"
              "void C_ParserPolicy::onError(" <<parserArgType <<", const bux::C_SourcePos &pos, std::string_view message) const\n"
              "{\n"
              "    RUNTIME_ERROR(\"{}@({},{}): {}\", pos.m_Source, pos.m_Line, pos.m_Col, message);\n"
              "}\n";
    out <<"\n"
          "} // namespace\n";
    m_Parsed.enterNamespaces(out);
    writeUserSection(out, "SCOPED_CPP_HEAD");
    if (!hasContext() || m_needGLR)
        fmt::print(out,
            "\n"
            "{}::{}(): bux::{}::C_Parser(g_policy) {{}}\n",
            headClassName, className, nsLR);
    else
        fmt::print(out,
            "\n"
            "const bux::{}::I_ParserPolicy &{}::policy() {{ return g_policy; }}\n",
            nsLR, headClassName);
    writeUserSection(out, "SCOPED_CPP_TAIL");
    m_Parsed.leaveNamespaces(out);
    out.close();

    // Ok
    return true;
}

void FC_Output::addParserMap(C_RenderReduction &rr, const std::string &className, size_t argInd) const
{
    rr.addMap("p", ARG_NAME_PARSER, 1<<argInd);
    rr.addMap("P", ARG_NAME_PARSER_DOWNCAST(className), 1<<argInd);
    if (!m_needGLR)
        // LR1
        rr.addMap("c", ARG_NAME_PARSER_DOWNCAST(className) ".m_context", 1<<argInd);
    else
        // GLR
    {
        std::string c = ARG_NAME_PARSER ".userData()";
        if (hasContext())
            c = "(*static_cast<" + className + "::C_Context*>(" + c + "))";

        rr.addMap("c", c, 1<<argInd);
    }
}

std::string FC_Output::outputFindKey(const C_Alphabet &alphabet)
{
    if (auto ret = m_alphaPrimes.find(alphabet))
    {
        const auto funcName = fmt::format("findPrime{}_{}_{}", ret->first, ret->second, alphabet.size());
        if (m_findPrimes.find(funcName) == m_findPrimes.end())
            // Not yet defined
        {
            auto out = "return findKey(" + alphaPrime(ret->first);
            if (ret->second)
                out += fmt::format("+{}", ret->second);

            m_findPrimes[funcName] = out += fmt::format(",{},key);", alphabet.size());
        }
        return funcName;
    }
    std::string s;
    for (auto i: alphabet)
    {
        s += s.empty()? '{': ',';
        s += m_lex2str.find(i)->second;
    }
    LOGIC_ERROR("Missing alphabet {}}}", s);
}

std::string FC_Output::outputIsKey(bux::T_LexID key) const
{
    m_isKeyCalled = true;
    return "isKey<" + m_lex2str.find(key)->second + '>';
}

void FC_Output::outputTokens(std::ostream &out, const std::string &headerBase) const
{
    auto found = m_Parsed.getOption("SCANNEROPTION");
    if (found)
        out <<ensureNoConcat(*found) <<'\n';

    const auto &literals = m_Parsed.literalMap();
    const auto ns = m_Parsed.fullNamespace();
    if (!literals.empty())
    {
        const bool ignoreCases = m_Parsed.ignoreKeywordCase();
        for (auto &i: literals)
        {
            const auto &s = i.first;
            out <<"_literal_" <<literalSuffix(s) <<" \t= ";
            if (!ignoreCases || !isKeyword(s))
                out <<'"' <<bux::asciiLiteral(s) <<"\"\t>>bux::createNothing<";
            else
            {
                size_t start = 0, end = 0;
                for (; end < s.size(); ++end)
                {
                    const char ch = s[end];
                    if (isalpha(ch))
                    {
                        if (start < end)
                            out <<'"' <<s.substr(start,end-start) <<'"';

                        out <<'[' <<char(std::toupper(ch)) <<char(std::tolower(ch)) <<']';
                        start = end + 1;
                    }
                }
                if (start < end)
                    out <<'"' <<s.substr(start,end-start) <<'"';

                out <<"\t>>bux::createPlainString<";;
            }
            out <<i.second <<",CHAR_TYPE> @+1\n";
        }
        out <<"_the_very_last_";
        bool first =true;
        for (auto &i: literals)
        {
            out <<(first?" = ":"|") <<"_literal_" <<literalSuffix(i.first);
            first =false;
        }
        found = m_Parsed.getOption("EXTRA_TOKENS");
        if (found && !found->empty())
            out <<" | " <<found->expand();

        out <<'\n';
    }
    else
    {
        found = m_Parsed.getOption("EXTRA_TOKENS");
        if (found && !found->empty())
            out <<"_the_very_last_ = " <<found->expand() <<'\n';
    }
    fmt::print(out,
                "\n"
                "%HEADERS_FOR_CPP     [[\n"
                "#include \"{}IdDef.h\"\n", headerBase);
    writeUserSection(out, "HEADERS_FOR_SCANNER_CPP");
    if (!ns.empty())
        out <<"using namespace " <<ns <<";\n";

    out <<"]]\n";
    if (m_Parsed.getOption("LOCALS_FOR_SCANNER_CPP"))
    {
        out <<"\n"
              "%LOCAL_ACTION_DEFS   [[\n";
        writeUserSection(out, "LOCALS_FOR_SCANNER_CPP");
        out <<"]]\n";
    }
}

size_t FC_Output::serial(const C_Production *prod) const
{
    auto i = m_ProdNums.find(prod);
    if (i == m_ProdNums.end())
        RUNTIME_ERROR("No production number");

    return i->second;
}

void FC_Output::writeUserSection(std::ostream &out, const char *optionKey) const
{
    if (const auto found = m_Parsed.getOption(optionKey))
        out <<"// Grammar %" <<optionKey <<" begins\n"
            <<ensureNoConcat(*found)
            <<"// Grammar %" <<optionKey <<" ends\n";
    else if (m_Parsed.getOption("SHOW_UNDEFINED"))
        out <<"// Grammar %" <<optionKey <<" undefined (expanded here otherwise)\n";
}

void FC_Output::C_RenderReduction::addMap(const std::string &key, const std::string &value, size_t argMask)
{
    auto &dst = m_replMap[key];
    dst.first = value;
    dst.second = argMask;
}

void FC_Output::C_RenderReduction::addGetMap(size_t argInd)
{
    m_getInd.emplace(argInd);
}

void FC_Output::C_RenderReduction::clearMap()
{
    m_replMap.clear();
    m_getInd.reset();
}

auto FC_Output::C_RenderReduction::render(std::string src, std::set<std::string> &unmapped) const -> T_StrFtMask
{
    T_StrFtMask ret;
    for (size_t i =0; (i = src.find('$',i)) != std::string::npos;)
    {
        size_t end = i;
        char c;
        do  c = src[++end];
            while (end < src.size() && isascii(c) && isalnum(c));

        if (++i < end)
            // Do replace
        {
            const auto name = src.substr(i, end-i);
            if (const size_t n = std::strtoul(name.c_str(), 0, 10))
            {
                if (!m_getInd)
                {
                    unmapped.insert(name);
                    i = end;
                }
                else
                {
                    const auto get = fmt::format(ARG_NAME_GETLEX "({})", n-1);
                    --i;
                    src.replace(i, end-i, get);
                    i += get.size();
                    ret.second |= 1 << *m_getInd;
                }
            }
            else
            {
                const auto found = m_replMap.find(name);
                if (found == m_replMap.end())
                {
                    unmapped.insert(name);
                    i = end;
                }
                else
                {
                    --i;
                    src.replace(i, end-i, found->second.first);
                    i += found->second.first.size();
                    ret.second |= found->second.second;
                }
            }
        }
    }
    ret.first.swap(src);
    return ret;
}
