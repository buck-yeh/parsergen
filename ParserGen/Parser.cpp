// This file is fully generated by running parsergen v1.6.2
// with grammer definition file "grammar.txt"

// Grammar %HEADERS_FOR_CPP begins
#include "ParseFile.h"      // parseFile()
//-----------------------------------------------------
#include <bux/StrUtil.h>    // bux::expand_env()
#include <bux/UnicodeCvt.h> // bux::to_utf8()
// Grammar %HEADERS_FOR_CPP ends
#include "Parser.h"
#include "ParserIdDef.h"
#include <bux/ImplLR1.h>
#include <bux/XException.h>

namespace {

using namespace bux::LR1;
using namespace Main;

//
//   Generated Constants
//
enum
{
    NID_All                  = TID_UB_+0,	// <All>
    NID_AssocType            = TID_UB_+1,	// <AssocType>
    NID_InterBracketed       = TID_UB_+2,	// <InterBracketed>
    NID_Line                 = TID_UB_+3,	// <Line>
    NID_NewLexIds            = TID_UB_+4,	// <NewLexIds>
    NID_OperatorAssociation  = TID_UB_+5,	// <OperatorAssociation>
    NID_OptionalTemplateArgs = TID_UB_+6,	// <OptionalTemplateArgs>
    NID_PreProcLine          = TID_UB_+7,	// <PreProcLine>
    NID_Production           = TID_UB_+8,	// <Production>
    NID_QualifiedName        = TID_UB_+9,	// <QualifiedName>
    NID_Semantics            = TID_UB_+10,	// <Semantics>
    NID_ShiftBase            = TID_UB_+11,	// <ShiftBase>
    NID_TemplateArg          = TID_UB_+12,	// <TemplateArg>
    NID_TemplateArgList      = TID_UB_+13,	// <TemplateArgList>
    NID_Terminal             = TID_UB_+14,	// <Terminal>
    NIDa_keyword             = TID_UB_+15,	// <@keyword>
    NIDa_operator            = TID_UB_+16,	// <@operator>
    TOKENGEN_UB,
    //---------------------------------------------------
    ENCODED_TOKEN_LB	 = 63
};
constexpr auto ZIP_TOKEN(auto x) { return x-(bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB); }

constinit const uint8_t
alphaPrime0[5] = {
    '\n',
    '<',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Nonterminal),
    ZIP_TOKEN(TID_LITERAL_3a3a)},
alphaPrime1[22] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Bracketed),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_LexSymbol),
    ZIP_TOKEN(TID_LEX_Nonterminal),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_KEYWORD_class),
    ZIP_TOKEN(TID_KEYWORD_else),
    ZIP_TOKEN(TID_KEYWORD_endif),
    ZIP_TOKEN(TID_KEYWORD_ifdef),
    ZIP_TOKEN(TID_KEYWORD_ifndef),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_KEYWORD_left),
    ZIP_TOKEN(TID_KEYWORD_lexid),
    ZIP_TOKEN(TID_KEYWORD_prec),
    ZIP_TOKEN(TID_KEYWORD_right),
    ZIP_TOKEN(TID_LITERAL_3a3a),
    ZIP_TOKEN(TID_LITERAL_3a3a3d)},
alphaPrime2[20] = {
    '\n',
    ZIP_TOKEN(bux::TID_EOF),
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_LexSymbol),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_KEYWORD_class),
    ZIP_TOKEN(TID_KEYWORD_else),
    ZIP_TOKEN(TID_KEYWORD_endif),
    ZIP_TOKEN(TID_KEYWORD_ifdef),
    ZIP_TOKEN(TID_KEYWORD_ifndef),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_KEYWORD_left),
    ZIP_TOKEN(TID_KEYWORD_lexid),
    ZIP_TOKEN(TID_KEYWORD_prec),
    ZIP_TOKEN(TID_KEYWORD_right),
    ZIP_TOKEN(TID_LITERAL_3a3a),
    ZIP_TOKEN(TID_LITERAL_3a3a3d)},
alphaPrime3[14] = {
    '#',
    '%',
    ZIP_TOKEN(TID_LEX_Nonterminal),
    ZIP_TOKEN(TID_KEYWORD_class),
    ZIP_TOKEN(TID_KEYWORD_left),
    ZIP_TOKEN(TID_KEYWORD_lexid),
    ZIP_TOKEN(TID_KEYWORD_prec),
    ZIP_TOKEN(TID_KEYWORD_right),
    ZIP_TOKEN(NID_All),
    ZIP_TOKEN(NID_AssocType),
    ZIP_TOKEN(NID_Line),
    ZIP_TOKEN(NID_NewLexIds),
    ZIP_TOKEN(NID_OperatorAssociation),
    ZIP_TOKEN(NID_Production)},
alphaPrime4[3] = {
    '%',
    ZIP_TOKEN(TID_LEX_LexSymbol),
    ZIP_TOKEN(NID_InterBracketed)},
alphaPrime5[4] = {
    '*',
    ',',
    '>',
    ZIP_TOKEN(TID_LEX_Id)},
alphaPrime6[2] = {
    '*',
    ZIP_TOKEN(TID_LEX_Id)},
alphaPrime7[4] = {
    '<',
    ZIP_TOKEN(TID_LEX_Nonterminal),
    ZIP_TOKEN(TID_LITERAL_3a3a),
    ZIP_TOKEN(NID_OptionalTemplateArgs)},
alphaPrime8[23] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_LexSymbol),
    ZIP_TOKEN(TID_LEX_Nonterminal),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_KEYWORD_class),
    ZIP_TOKEN(TID_KEYWORD_else),
    ZIP_TOKEN(TID_KEYWORD_endif),
    ZIP_TOKEN(TID_KEYWORD_ifdef),
    ZIP_TOKEN(TID_KEYWORD_ifndef),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_KEYWORD_left),
    ZIP_TOKEN(TID_KEYWORD_lexid),
    ZIP_TOKEN(TID_KEYWORD_prec),
    ZIP_TOKEN(TID_KEYWORD_right),
    ZIP_TOKEN(TID_LITERAL_3a3a),
    ZIP_TOKEN(TID_LITERAL_3a3a3d),
    ZIP_TOKEN(NID_Semantics),
    ZIP_TOKEN(NID_Terminal),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)},
alphaPrime9[21] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(TID_LEX_Key),
    ZIP_TOKEN(TID_LEX_LexSymbol),
    ZIP_TOKEN(TID_LEX_Num),
    ZIP_TOKEN(TID_LEX_Operator),
    ZIP_TOKEN(TID_LEX_String),
    ZIP_TOKEN(TID_KEYWORD_class),
    ZIP_TOKEN(TID_KEYWORD_else),
    ZIP_TOKEN(TID_KEYWORD_endif),
    ZIP_TOKEN(TID_KEYWORD_ifdef),
    ZIP_TOKEN(TID_KEYWORD_ifndef),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(TID_KEYWORD_left),
    ZIP_TOKEN(TID_KEYWORD_lexid),
    ZIP_TOKEN(TID_KEYWORD_prec),
    ZIP_TOKEN(TID_KEYWORD_right),
    ZIP_TOKEN(TID_LITERAL_3a3a),
    ZIP_TOKEN(TID_LITERAL_3a3a3d),
    ZIP_TOKEN(NID_Terminal),
    ZIP_TOKEN(NIDa_keyword),
    ZIP_TOKEN(NIDa_operator)},
alphaPrime10[2] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_QualifiedName)},
alphaPrime11[3] = {
    ZIP_TOKEN(TID_LEX_Id),
    ZIP_TOKEN(NID_TemplateArg),
    ZIP_TOKEN(NID_TemplateArgList)},
alphaPrime12[6] = {
    ZIP_TOKEN(TID_KEYWORD_else),
    ZIP_TOKEN(TID_KEYWORD_endif),
    ZIP_TOKEN(TID_KEYWORD_ifdef),
    ZIP_TOKEN(TID_KEYWORD_ifndef),
    ZIP_TOKEN(TID_KEYWORD_include),
    ZIP_TOKEN(NID_PreProcLine)};

template<uint8_t KEY> int isKey(uint8_t key)
{
    return key == KEY? 0: -1;
}

int findKey(const uint8_t *klist, int n, uint8_t key)
{
    for (int i = 0; i < n; ++i)
         if (key == klist[i])
             return i;
    return -1;
}

int findPrime0_0_5	(uint8_t key)	{ return findKey(alphaPrime0,5,key); }
int findPrime10_0_2	(uint8_t key)	{ return findKey(alphaPrime10,2,key); }
int findPrime11_0_3	(uint8_t key)	{ return findKey(alphaPrime11,3,key); }
int findPrime12_0_6	(uint8_t key)	{ return findKey(alphaPrime12,6,key); }
int findPrime1_0_2	(uint8_t key)	{ return findKey(alphaPrime1,2,key); }
int findPrime1_0_22	(uint8_t key)	{ return findKey(alphaPrime1,22,key); }
int findPrime1_0_3	(uint8_t key)	{ return findKey(alphaPrime1,3,key); }
int findPrime1_11_5	(uint8_t key)	{ return findKey(alphaPrime1+11,5,key); }
int findPrime2_0_20	(uint8_t key)	{ return findKey(alphaPrime2,20,key); }
int findPrime2_0_3	(uint8_t key)	{ return findKey(alphaPrime2,3,key); }
int findPrime3_0_14	(uint8_t key)	{ return findKey(alphaPrime3,14,key); }
int findPrime4_0_3	(uint8_t key)	{ return findKey(alphaPrime4,3,key); }
int findPrime5_0_4	(uint8_t key)	{ return findKey(alphaPrime5,4,key); }
int findPrime5_1_2	(uint8_t key)	{ return findKey(alphaPrime5+1,2,key); }
int findPrime6_0_2	(uint8_t key)	{ return findKey(alphaPrime6,2,key); }
int findPrime7_0_4	(uint8_t key)	{ return findKey(alphaPrime7,4,key); }
int findPrime8_0_23	(uint8_t key)	{ return findKey(alphaPrime8,23,key); }
int findPrime9_0_21	(uint8_t key)	{ return findKey(alphaPrime9,21,key); }

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2A_Table0[] ={
    {'\n',	ACTION_REDUCE_MIN + 2},
    {'#',	ACTION_SHIFT},
    {'%',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 2},
    {ZIP_TOKEN(TID_LEX_Nonterminal),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_class),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_left),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_lexid),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_prec),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_right),	ACTION_SHIFT}},
L2A_Table1[] ={
    {'\n',	ACTION_REDUCE_MIN + 5},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 5},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT}},
L2A_Table2[] ={
    {'\n',	ACTION_REDUCE_MIN + 6},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 6},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_LexSymbol),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_class),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_else),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_endif),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_ifdef),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_ifndef),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_left),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_lexid),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_prec),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_right),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3a3a),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3a3a3d),	ACTION_SHIFT}},
L2A_Table3[] ={
    {'\n',	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 7},
    {ZIP_TOKEN(TID_LEX_Bracketed),	ACTION_SHIFT}},
L2A_Table4[] ={
    {'\n',	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 8},
    {ZIP_TOKEN(TID_LEX_Bracketed),	ACTION_SHIFT}},
L2A_Table5[] ={
    {'\n',	ACTION_REDUCE_MIN + 14},
    {'<',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 14},
    {ZIP_TOKEN(TID_LEX_Nonterminal),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3a3a),	ACTION_SHIFT}},
L2A_Table6[] ={
    {'\n',	ACTION_REDUCE_MIN + 24},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 24},
    {ZIP_TOKEN(TID_LEX_Bracketed),	ACTION_REDUCE_MIN + 24},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Key),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_LexSymbol),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Nonterminal),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Num),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_Operator),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LEX_String),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_class),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_else),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_endif),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_ifdef),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_ifndef),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_include),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_left),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_lexid),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_prec),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_KEYWORD_right),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3a3a),	ACTION_SHIFT},
    {ZIP_TOKEN(TID_LITERAL_3a3a3d),	ACTION_SHIFT}},
L2A_Table7[] ={
    {'\n',	ACTION_REDUCE_MIN + 26},
    {'%',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_REDUCE_MIN + 26},
    {ZIP_TOKEN(TID_LEX_Bracketed),	ACTION_REDUCE_MIN + 26},
    {ZIP_TOKEN(TID_LEX_LexSymbol),	ACTION_SHIFT}},
L2A_Table8[] ={
    {'\n',	ACTION_SHIFT},
    {ZIP_TOKEN(bux::TID_EOF),	ACTION_ACCEPT}},
L2A_Table9[] ={
    {'*',	ACTION_SHIFT},
    {',',	ACTION_REDUCE_MIN + 38},
    {'>',	ACTION_REDUCE_MIN + 38},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT}},
L2A_Table10[] ={
    {'*',	ACTION_SHIFT},
    {',',	ACTION_REDUCE_MIN + 39},
    {'>',	ACTION_REDUCE_MIN + 39},
    {ZIP_TOKEN(TID_LEX_Id),	ACTION_SHIFT}};

constinit const bux::U_K2V<uint8_t,uint8_t> mapActionPtr[94] ={
    L2A_Table0,	// 0
    findPrime1_11_5,	// 1
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 2
    isKey<ZIP_TOKEN(TID_LITERAL_3a3a3d)>,	// 3
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 4
    findPrime2_0_20,	// 5
    findPrime2_0_3,	// 6
    findPrime2_0_20,	// 7
    findPrime2_0_20,	// 8
    L2A_Table8,	// 9
    findPrime2_0_20,	// 10
    findPrime1_0_2,	// 11
    L2A_Table1,	// 12
    L2A_Table2,	// 13
    L2A_Table6,	// 14
    findPrime1_0_2,	// 15
    findPrime1_0_2,	// 16
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 17
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 18
    isKey<ZIP_TOKEN(TID_LEX_String)>,	// 19
    findPrime1_0_2,	// 20
    findPrime1_0_3,	// 21
    findPrime1_0_22,	// 22
    findPrime0_0_5,	// 23
    L2A_Table5,	// 24
    L2A_Table0,	// 25
    findPrime2_0_3,	// 26
    findPrime2_0_20,	// 27
    findPrime2_0_20,	// 28
    findPrime2_0_20,	// 29
    findPrime2_0_20,	// 30
    findPrime2_0_20,	// 31
    findPrime2_0_20,	// 32
    findPrime2_0_20,	// 33
    findPrime2_0_20,	// 34
    findPrime2_0_20,	// 35
    findPrime2_0_20,	// 36
    findPrime2_0_20,	// 37
    findPrime2_0_20,	// 38
    findPrime2_0_20,	// 39
    findPrime2_0_20,	// 40
    findPrime2_0_20,	// 41
    findPrime2_0_20,	// 42
    findPrime2_0_20,	// 43
    findPrime2_0_20,	// 44
    findPrime2_0_20,	// 45
    findPrime2_0_20,	// 46
    findPrime2_0_20,	// 47
    findPrime1_0_22,	// 48
    findPrime1_0_22,	// 49
    findPrime1_0_22,	// 50
    findPrime1_0_22,	// 51
    findPrime1_0_22,	// 52
    findPrime1_0_22,	// 53
    findPrime1_0_22,	// 54
    findPrime1_0_22,	// 55
    findPrime1_0_22,	// 56
    findPrime1_0_22,	// 57
    findPrime1_0_22,	// 58
    findPrime1_0_22,	// 59
    findPrime1_0_22,	// 60
    findPrime1_0_22,	// 61
    findPrime1_0_22,	// 62
    findPrime1_0_22,	// 63
    findPrime1_0_22,	// 64
    findPrime1_0_22,	// 65
    findPrime1_0_22,	// 66
    L2A_Table4,	// 67
    findPrime1_0_22,	// 68
    findPrime1_0_22,	// 69
    findPrime1_0_22,	// 70
    findPrime1_0_2,	// 71
    findPrime1_0_2,	// 72
    findPrime1_0_2,	// 73
    L2A_Table3,	// 74
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 75
    findPrime1_0_2,	// 76
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 77
    findPrime1_0_2,	// 78
    findPrime1_0_2,	// 79
    L2A_Table7,	// 80
    findPrime5_0_4,	// 81
    L2A_Table9,	// 82
    findPrime5_1_2,	// 83
    findPrime0_0_5,	// 84
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 85
    findPrime1_0_3,	// 86
    findPrime1_0_3,	// 87
    findPrime5_0_4,	// 88
    findPrime5_0_4,	// 89
    isKey<ZIP_TOKEN(TID_LEX_Id)>,	// 90
    findPrime1_0_2,	// 91
    findPrime1_0_3,	// 92
    L2A_Table10};	// 93

constinit const int8_t mapActionSizeEx[94] ={
    -10,	// 0
    ACTION_SHIFT,	// 1
    ACTION_SHIFT,	// 2
    ACTION_SHIFT,	// 3
    ACTION_SHIFT,	// 4
    ACTION_REDUCE_MIN + 21,	// 5
    ACTION_REDUCE_MIN + 17,	// 6
    ACTION_REDUCE_MIN + 23,	// 7
    ACTION_REDUCE_MIN + 22,	// 8
    -2,	// 9
    ACTION_REDUCE_MIN + 19,	// 10
    ACTION_REDUCE_MIN + 0,	// 11
    -3,	// 12
    -20,	// 13
    -22,	// 14
    ACTION_REDUCE_MIN + 11,	// 15
    ACTION_REDUCE_MIN + 12,	// 16
    ACTION_SHIFT,	// 17
    ACTION_SHIFT,	// 18
    ACTION_SHIFT,	// 19
    ACTION_REDUCE_MIN + 3,	// 20
    ACTION_REDUCE_MIN + 24,	// 21
    ACTION_REDUCE_MIN + 33,	// 22
    ACTION_REDUCE_MIN + 36,	// 23
    -5,	// 24
    -10,	// 25
    ACTION_REDUCE_MIN + 18,	// 26
    ACTION_REDUCE_MIN + 49,	// 27
    ACTION_REDUCE_MIN + 46,	// 28
    ACTION_REDUCE_MIN + 43,	// 29
    ACTION_REDUCE_MIN + 45,	// 30
    ACTION_REDUCE_MIN + 47,	// 31
    ACTION_REDUCE_MIN + 44,	// 32
    ACTION_REDUCE_MIN + 54,	// 33
    ACTION_REDUCE_MIN + 55,	// 34
    ACTION_REDUCE_MIN + 56,	// 35
    ACTION_REDUCE_MIN + 57,	// 36
    ACTION_REDUCE_MIN + 58,	// 37
    ACTION_REDUCE_MIN + 59,	// 38
    ACTION_REDUCE_MIN + 60,	// 39
    ACTION_REDUCE_MIN + 61,	// 40
    ACTION_REDUCE_MIN + 62,	// 41
    ACTION_REDUCE_MIN + 63,	// 42
    ACTION_REDUCE_MIN + 52,	// 43
    ACTION_REDUCE_MIN + 53,	// 44
    ACTION_REDUCE_MIN + 20,	// 45
    ACTION_REDUCE_MIN + 50,	// 46
    ACTION_REDUCE_MIN + 48,	// 47
    ACTION_REDUCE_MIN + 49,	// 48
    ACTION_REDUCE_MIN + 46,	// 49
    ACTION_REDUCE_MIN + 43,	// 50
    ACTION_REDUCE_MIN + 34,	// 51
    ACTION_REDUCE_MIN + 45,	// 52
    ACTION_REDUCE_MIN + 47,	// 53
    ACTION_REDUCE_MIN + 44,	// 54
    ACTION_REDUCE_MIN + 54,	// 55
    ACTION_REDUCE_MIN + 55,	// 56
    ACTION_REDUCE_MIN + 56,	// 57
    ACTION_REDUCE_MIN + 57,	// 58
    ACTION_REDUCE_MIN + 58,	// 59
    ACTION_REDUCE_MIN + 59,	// 60
    ACTION_REDUCE_MIN + 60,	// 61
    ACTION_REDUCE_MIN + 61,	// 62
    ACTION_REDUCE_MIN + 62,	// 63
    ACTION_REDUCE_MIN + 63,	// 64
    ACTION_REDUCE_MIN + 52,	// 65
    ACTION_REDUCE_MIN + 53,	// 66
    -3,	// 67
    ACTION_REDUCE_MIN + 35,	// 68
    ACTION_REDUCE_MIN + 50,	// 69
    ACTION_REDUCE_MIN + 48,	// 70
    ACTION_REDUCE_MIN + 9,	// 71
    ACTION_REDUCE_MIN + 10,	// 72
    ACTION_REDUCE_MIN + 13,	// 73
    -3,	// 74
    ACTION_SHIFT,	// 75
    ACTION_REDUCE_MIN + 16,	// 76
    ACTION_SHIFT,	// 77
    ACTION_REDUCE_MIN + 4,	// 78
    ACTION_REDUCE_MIN + 1,	// 79
    -5,	// 80
    ACTION_REDUCE_MIN + 40,	// 81
    -4,	// 82
    ACTION_SHIFT,	// 83
    ACTION_REDUCE_MIN + 37,	// 84
    ACTION_SHIFT,	// 85
    ACTION_REDUCE_MIN + 27,	// 86
    ACTION_REDUCE_MIN + 25,	// 87
    ACTION_REDUCE_MIN + 42,	// 88
    ACTION_REDUCE_MIN + 41,	// 89
    ACTION_SHIFT,	// 90
    ACTION_REDUCE_MIN + 15,	// 91
    ACTION_REDUCE_MIN + 28,	// 92
    -4};	// 93

constinit const bux::C_KVPair<uint8_t,uint8_t>
L2S_Table0[] ={
    {'#',	1},
    {'%',	2},
    {ZIP_TOKEN(TID_LEX_Nonterminal),	3},
    {ZIP_TOKEN(TID_KEYWORD_class),	4},
    {ZIP_TOKEN(TID_KEYWORD_left),	5},
    {ZIP_TOKEN(TID_KEYWORD_lexid),	6},
    {ZIP_TOKEN(TID_KEYWORD_prec),	7},
    {ZIP_TOKEN(TID_KEYWORD_right),	8},
    {ZIP_TOKEN(NID_AssocType),	10},
    {ZIP_TOKEN(NID_Line),	79},
    {ZIP_TOKEN(NID_NewLexIds),	12},
    {ZIP_TOKEN(NID_OperatorAssociation),	13},
    {ZIP_TOKEN(NID_Production),	14}},
L2S_Table1[] ={
    {ZIP_TOKEN(TID_LEX_Id),	81},
    {ZIP_TOKEN(NID_TemplateArg),	93}};

constinit const struct C_MapGoto {
    bux::U_K2V<uint8_t,uint8_t> m_k2v;
    uint8_t	m_curState;
    int8_t	m_nextStateEx;
}   mapGoto[25] ={
    {findPrime3_0_14,	0,	1},
    {findPrime12_0_6,	1,	15},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	2,	21},
    {isKey<ZIP_TOKEN(TID_LITERAL_3a3a3d)>,	3,	22},
    {findPrime10_0_2,	4,	23},
    {isKey<'\n'>,	9,	25},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	12,	26},
    {findPrime9_0_21,	13,	27},
    {findPrime8_0_23,	14,	48},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	17,	71},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	18,	72},
    {isKey<ZIP_TOKEN(TID_LEX_String)>,	19,	73},
    {isKey<ZIP_TOKEN(NID_Semantics)>,	21,	74},
    {findPrime7_0_4,	24,	75},
    {L2S_Table0,	25,	-13},
    {isKey<ZIP_TOKEN(TID_LEX_Bracketed)>,	67,	80},
    {isKey<ZIP_TOKEN(TID_LEX_Bracketed)>,	74,	80},
    {findPrime11_0_3,	75,	81},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	77,	84},
    {findPrime4_0_3,	80,	85},
    {findPrime6_0_2,	82,	88},
    {findPrime5_1_2,	83,	90},
    {isKey<ZIP_TOKEN(TID_LEX_Id)>,	85,	92},
    {L2S_Table1,	90,	-2},
    {findPrime6_0_2,	93,	88}};

void _reduce_1(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= class <QualifiedName> <OptionalTemplateArgs>
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    if (auto targs = bux::tryUnlex<C_TemplateArgs>(_geT_(2)))
    {
        if (auto err = c.setClassName(bux::unlex<C_StringList>(_geT_(1)), *targs))
            _paRSeR_.onError(_geT_(0), *err);
    }
    else
    {
        C_TemplateArgs t;
        if (auto sarg = bux::tryUnlex<std::string>(_geT_(2)))
            t.emplace_back().emplace_back(*sarg);

        if (auto err = c.setClassName(bux::unlex<C_StringList>(_geT_(1)), t))
            _paRSeR_.onError(_geT_(0), *err);
    }
}

void _reduce_2(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= <OperatorAssociation>
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    _geT_(0).m_attr.disown(); // not a pointer
    c.incWeight();
}

void _reduce_3(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= % $Id <Semantics>
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    c.addOption(bux::unlex<std::string>(_geT_(1)), bux::tryUnlex<C_Semantic>(_geT_(2)));
}

void _reduce_4(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <Line> ::= <Production> <Semantics>
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    auto &prod = dynamic_cast<C_Production&>(*_geT_(0));
    if (!c.addProduction(prod, bux::tryUnlex<C_Semantic>(_geT_(1))))
        _paRSeR_.onError(_geT_(0), "Production re-defined:\n"
                             "\t" + prod.str());
}

void _reduce_5(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <PreProcLine> ::= ifdef $Id
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    c.ifCond(c.getOption(bux::unlex<std::string>(_geT_(1))), _geT_(0));
}

void _reduce_6(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <PreProcLine> ::= ifndef $Id
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    c.ifCond(!c.getOption(bux::unlex<std::string>(_geT_(1))), _geT_(0));
}

void _reduce_7(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <PreProcLine> ::= else
{
    dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context.elseCond(_geT_(0));
}

void _reduce_8(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <PreProcLine> ::= endif
{
    dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context.endifCond(_geT_(0));
}

void _reduce_9(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <PreProcLine> ::= include $String
{
    auto &C = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!C.testCond())
        return;

    const auto filename = C.expand_include(bux::unlex<std::string>(_geT_(1)));
    _paRSeR_.reservePostShift([&,filename]{
            parseFile(filename, dynamic_cast<Main::C_BNFParser&>(_paRSeR_), '\n');
        }, 1);
}

void _reduce_10(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionalTemplateArgs> ::= < <TemplateArgList> >
//  <ShiftBase> ::= + $Num
{
    _reT_ = _geT_(1);
}

void _reduce_11(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OptionalTemplateArgs> ::= $Nonterminal
//  <OperatorAssociation> ::= <AssocType>
//  <ShiftBase> ::= $Num
//  <Terminal> ::= $Num
{
    _reT_ = _geT_(0);
}

void _reduce_12(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval )
//  <NewLexIds> ::= <NewLexIds> $Id
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    auto &lex =_geT_(1);
    const auto &key = bux::unlex<std::string>(lex);
    if (!c.addLexId(key))
        _paRSeR_.onError(lex, "Duplicate lex id: "+key);
}

void _reduce_13(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <OperatorAssociation> ::= <OperatorAssociation> <Terminal>
{
    auto &c = dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context;
    if (!c.testCond())
        return;

    c.addPriority(bux::unlex<E_Associativity>(_geT_(0)), _geT_(1));
    _reT_ = _geT_(0);
}

void _reduce_14(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <AssocType> ::= left
{
    _reT_ = bux::createLex(LEFT2RIGHT);
}

void _reduce_15(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <AssocType> ::= right
{
    _reT_ = bux::createLex(RIGHT2LEFT);
}

void _reduce_16(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <AssocType> ::= prec
{
    _reT_ = bux::createLex(ASSOC_NONE);
}

void _reduce_17(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Semantics> ::= <Semantics> $Bracketed <InterBracketed>
{
    C_NewLex<C_Semantic> dst(_geT_(0));
    auto &s = bux::unlex<std::string>(_geT_(1));
    if (!s.empty())
        dst->m_data.emplace_back(new C_BracketedLex(s));

    if (I_SemanticChunk *t = _geT_(2))
    {
        dst->m_data.emplace_back(t);
        _geT_(2).m_attr.disown();
    }
    _reT_ = dst;
}

void _reduce_18(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <InterBracketed> ::= $LexSymbol
{
    _reT_ = new C_LexSymbol(bux::unlex<std::string>(_geT_(0)));
}

void _reduce_19(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <InterBracketed> ::= % $Id
{
    _reT_ = new C_OptionLex(bux::unlex<std::string>(_geT_(1)));
}

void _reduce_20(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <ShiftBase> ::= - $Num
{
    _reT_ =_geT_(0);
    dynamic_cast<C_IntegerLex&>(*_reT_).negate();
}

void _reduce_21(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Production> ::= $Nonterminal ::=
{
    auto const t = new C_ProductionLex;
    try
    {
        t->m_Lval = bux::unlex<std::string>(_geT_(0));
        if (t->m_Lval == "@keyword" ||
            t->m_Lval == "@operator" )
            _paRSeR_.onError(_geT_(0), fmt::format("Reserved non-terminal <{}> not allowed on left side of production", t->m_Lval));

        _reT_ = t; // good or bad
    }
    catch (...)
    {
        delete t;
        throw;
    }
}

void _reduce_22(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Production> ::= <Production> $Nonterminal
{
    _reT_ = _geT_(0);
    const auto s = bux::unlex<std::string>(_geT_(1));
    if (s.size() > 1 && s[0] == '@')
        // Builtin nonterminal which triggers extra productions
    {
        if (!dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context.activateBuiltinNonterminal(s.substr(1)))
            _paRSeR_.onError(_geT_(1), "Unrecognized as a builtin nonterminal");
    }
    auto t = new C_Nonterminal(s);
    try
    {
        dynamic_cast<C_Production&>(*_reT_).m_Rval.emplace_back(t);
    }
    catch (...)
    {
        delete t;
        throw;
    }
}

void _reduce_23(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Production> ::= <Production> <Terminal>
{
    _reT_ = _geT_(0);
    auto &dst = dynamic_cast<C_Production&>(*_reT_).m_Rval;
    C_LexPtr &src = _geT_(1);
    if (I_Terminal *t = src)
    {
        dst.emplace_back(t);
        src.disown();
    }
    else if (C_IntegerLex *i = src)
        dst.emplace_back(new C_StrLiteral(i->str()));
    else
        _paRSeR_.onError(_geT_(1), "Unknown production term");
}

void _reduce_24(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <QualifiedName> ::= $Id
//  <TemplateArg> ::= $Id
{
    C_StringList t;
    t.emplace_back(bux::unlex<std::string>(_geT_(0)));
    _reT_ = bux::createLex(t);
}

void _reduce_25(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <QualifiedName> ::= <QualifiedName> :: $Id
{
    bux::unlex<C_StringList>(_geT_(0)).emplace_back(bux::unlex<std::string>(_geT_(2)));
    _reT_ = _geT_(0);
}

void _reduce_26(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <TemplateArgList> ::= <TemplateArg>
{
    C_NewLex<C_TemplateArgs> t;
    t->m_data.emplace_back(bux::unlex<C_StringList>(_geT_(0)));
    _reT_ = t;
}

void _reduce_27(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <TemplateArgList> ::= <TemplateArgList> , <TemplateArg>
{
    bux::unlex<C_TemplateArgs>(_geT_(0)).emplace_back(bux::unlex<C_StringList>(_geT_(2)));
    _reT_ = _geT_(0);
}

void _reduce_28(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <TemplateArg> ::= <TemplateArg> $Id
{
    bux::unlex<C_StringList>(_geT_(0)).emplace_back(bux::unlex<std::string>(_geT_(1)));
    _reT_ = _geT_(0);
}

void _reduce_29(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <TemplateArg> ::= <TemplateArg> *
{
    bux::unlex<C_StringList>(_geT_(0)).emplace_back("*");
    _reT_ = _geT_(0);
}

void _reduce_30(bux::LR1::C_Parser &_paRSeR_, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Terminal> ::= $LexSymbol
{
    const auto &s = bux::unlex<std::string>(_geT_(0));
    dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context.addLexId(s);
    _reT_ = new C_LexSymbol(s);
}

void _reduce_31(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Terminal> ::= $String
{
    _reT_ = new C_StrLiteral(bux::unlex<std::string>(_geT_(0)), '\"');
}

void _reduce_32(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Terminal> ::= $Key
{
    const auto c = bux::unlex<T_Utf32>(_geT_(0));
    _reT_ = new C_StrLiteral{to_utf8(c), '\''};
}

void _reduce_33(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Terminal> ::= $Operator
//  <Terminal> ::= <@operator>
{
    _reT_ = new C_StrLiteral(bux::unlex<std::string>(_geT_(0)));
}

void _reduce_34(bux::LR1::C_Parser &, const F_GetProduced &_geT_, C_RetLval _reT_)
//  <Terminal> ::= $Id
//  <Terminal> ::= <@keyword>
{
    _reT_ = new C_Id(bux::unlex<std::string>(_geT_(0)));
}

void _reduce_35(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@operator> ::= ::
{
    _reT_ = createLex<std::string>("::");
}

void _reduce_36(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@operator> ::= ::=
{
    _reT_ = createLex<std::string>("::=");
}

void _reduce_37(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= class
{
    _reT_ = createLex<std::string>("class");
}

void _reduce_38(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= else
{
    _reT_ = createLex<std::string>("else");
}

void _reduce_39(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= endif
{
    _reT_ = createLex<std::string>("endif");
}

void _reduce_40(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= ifdef
{
    _reT_ = createLex<std::string>("ifdef");
}

void _reduce_41(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= ifndef
{
    _reT_ = createLex<std::string>("ifndef");
}

void _reduce_42(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= include
{
    _reT_ = createLex<std::string>("include");
}

void _reduce_43(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= left
{
    _reT_ = createLex<std::string>("left");
}

void _reduce_44(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= lexid
{
    _reT_ = createLex<std::string>("lexid");
}

void _reduce_45(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= prec
{
    _reT_ = createLex<std::string>("prec");
}

void _reduce_46(bux::LR1::C_Parser &, const F_GetProduced &, C_RetLval _reT_)
//  <@keyword> ::= right
{
    _reT_ = createLex<std::string>("right");
}

struct C_ProductionInfo
{
    void            (*m_pAction)(bux::LR1::C_Parser&,const F_GetProduced&,C_RetLval);
    uint8_t         m_ReducedID;
    uint8_t         m_PopLength;
} constinit const prodInfo[64] ={
{nullptr,    	ZIP_TOKEN(NID_All),         1},	// 0: <All> ::= <Line>
{nullptr,    	ZIP_TOKEN(NID_All),         3},	// 1: <All> ::= <All> "\n" <Line>
{nullptr,    	ZIP_TOKEN(NID_Line),        0},	// 2: <Line> ::=
{nullptr,    	ZIP_TOKEN(NID_Line),        2},	// 3: <Line> ::= # <PreProcLine>
{_reduce_1, 	ZIP_TOKEN(NID_Line),        3},	// 4: <Line> ::= class <QualifiedName> <OptionalTemplateArgs>
{nullptr,    	ZIP_TOKEN(NID_Line),        1},	// 5: <Line> ::= <NewLexIds>
{_reduce_2, 	ZIP_TOKEN(NID_Line),        1},	// 6: <Line> ::= <OperatorAssociation>
{_reduce_3, 	ZIP_TOKEN(NID_Line),        3},	// 7: <Line> ::= % $Id <Semantics>
{_reduce_4, 	ZIP_TOKEN(NID_Line),        2},	// 8: <Line> ::= <Production> <Semantics>
{_reduce_5, 	ZIP_TOKEN(NID_PreProcLine), 2},	// 9: <PreProcLine> ::= ifdef $Id
{_reduce_6, 	ZIP_TOKEN(NID_PreProcLine), 2},	// 10: <PreProcLine> ::= ifndef $Id
{_reduce_7, 	ZIP_TOKEN(NID_PreProcLine), 1},	// 11: <PreProcLine> ::= else
{_reduce_8, 	ZIP_TOKEN(NID_PreProcLine), 1},	// 12: <PreProcLine> ::= endif
{_reduce_9, 	ZIP_TOKEN(NID_PreProcLine), 2},	// 13: <PreProcLine> ::= include $String
{nullptr,    	ZIP_TOKEN(NID_OptionalTemplateArgs), 0},	// 14: <OptionalTemplateArgs> ::=
{_reduce_10,	ZIP_TOKEN(NID_OptionalTemplateArgs), 3},	// 15: <OptionalTemplateArgs> ::= < <TemplateArgList> >
{_reduce_11,	ZIP_TOKEN(NID_OptionalTemplateArgs), 1},	// 16: <OptionalTemplateArgs> ::= $Nonterminal
{nullptr,    	ZIP_TOKEN(NID_NewLexIds),   1},	// 17: <NewLexIds> ::= lexid
{_reduce_12,	ZIP_TOKEN(NID_NewLexIds),   2},	// 18: <NewLexIds> ::= <NewLexIds> $Id
{_reduce_11,	ZIP_TOKEN(NID_OperatorAssociation), 1},	// 19: <OperatorAssociation> ::= <AssocType>
{_reduce_13,	ZIP_TOKEN(NID_OperatorAssociation), 2},	// 20: <OperatorAssociation> ::= <OperatorAssociation> <Terminal>
{_reduce_14,	ZIP_TOKEN(NID_AssocType),   1},	// 21: <AssocType> ::= left
{_reduce_15,	ZIP_TOKEN(NID_AssocType),   1},	// 22: <AssocType> ::= right
{_reduce_16,	ZIP_TOKEN(NID_AssocType),   1},	// 23: <AssocType> ::= prec
{nullptr,    	ZIP_TOKEN(NID_Semantics),   0},	// 24: <Semantics> ::=
{_reduce_17,	ZIP_TOKEN(NID_Semantics),   3},	// 25: <Semantics> ::= <Semantics> $Bracketed <InterBracketed>
{nullptr,    	ZIP_TOKEN(NID_InterBracketed), 0},	// 26: <InterBracketed> ::=
{_reduce_18,	ZIP_TOKEN(NID_InterBracketed), 1},	// 27: <InterBracketed> ::= $LexSymbol
{_reduce_19,	ZIP_TOKEN(NID_InterBracketed), 2},	// 28: <InterBracketed> ::= % $Id
{nullptr,    	ZIP_TOKEN(NID_ShiftBase),   0},	// 29: <ShiftBase> ::=
{_reduce_11,	ZIP_TOKEN(NID_ShiftBase),   1},	// 30: <ShiftBase> ::= $Num
{_reduce_10,	ZIP_TOKEN(NID_ShiftBase),   2},	// 31: <ShiftBase> ::= + $Num
{_reduce_20,	ZIP_TOKEN(NID_ShiftBase),   2},	// 32: <ShiftBase> ::= - $Num
{_reduce_21,	ZIP_TOKEN(NID_Production),  2},	// 33: <Production> ::= $Nonterminal ::=
{_reduce_22,	ZIP_TOKEN(NID_Production),  2},	// 34: <Production> ::= <Production> $Nonterminal
{_reduce_23,	ZIP_TOKEN(NID_Production),  2},	// 35: <Production> ::= <Production> <Terminal>
{_reduce_24,	ZIP_TOKEN(NID_QualifiedName), 1},	// 36: <QualifiedName> ::= $Id
{_reduce_25,	ZIP_TOKEN(NID_QualifiedName), 3},	// 37: <QualifiedName> ::= <QualifiedName> :: $Id
{_reduce_26,	ZIP_TOKEN(NID_TemplateArgList), 1},	// 38: <TemplateArgList> ::= <TemplateArg>
{_reduce_27,	ZIP_TOKEN(NID_TemplateArgList), 3},	// 39: <TemplateArgList> ::= <TemplateArgList> , <TemplateArg>
{_reduce_24,	ZIP_TOKEN(NID_TemplateArg), 1},	// 40: <TemplateArg> ::= $Id
{_reduce_28,	ZIP_TOKEN(NID_TemplateArg), 2},	// 41: <TemplateArg> ::= <TemplateArg> $Id
{_reduce_29,	ZIP_TOKEN(NID_TemplateArg), 2},	// 42: <TemplateArg> ::= <TemplateArg> *
{_reduce_30,	ZIP_TOKEN(NID_Terminal),    1},	// 43: <Terminal> ::= $LexSymbol
{_reduce_31,	ZIP_TOKEN(NID_Terminal),    1},	// 44: <Terminal> ::= $String
{_reduce_11,	ZIP_TOKEN(NID_Terminal),    1},	// 45: <Terminal> ::= $Num
{_reduce_32,	ZIP_TOKEN(NID_Terminal),    1},	// 46: <Terminal> ::= $Key
{_reduce_33,	ZIP_TOKEN(NID_Terminal),    1},	// 47: <Terminal> ::= $Operator
{_reduce_33,	ZIP_TOKEN(NID_Terminal),    1},	// 48: <Terminal> ::= <@operator>
{_reduce_34,	ZIP_TOKEN(NID_Terminal),    1},	// 49: <Terminal> ::= $Id
{_reduce_34,	ZIP_TOKEN(NID_Terminal),    1},	// 50: <Terminal> ::= <@keyword>
{nullptr,    	ZIP_TOKEN(bux::ROOT_NID),   1},	// 51: <@> ::= <All>
{_reduce_35,	ZIP_TOKEN(NIDa_operator),   1},	// 52: <@operator> ::= ::
{_reduce_36,	ZIP_TOKEN(NIDa_operator),   1},	// 53: <@operator> ::= ::=
{_reduce_37,	ZIP_TOKEN(NIDa_keyword),    1},	// 54: <@keyword> ::= class
{_reduce_38,	ZIP_TOKEN(NIDa_keyword),    1},	// 55: <@keyword> ::= else
{_reduce_39,	ZIP_TOKEN(NIDa_keyword),    1},	// 56: <@keyword> ::= endif
{_reduce_40,	ZIP_TOKEN(NIDa_keyword),    1},	// 57: <@keyword> ::= ifdef
{_reduce_41,	ZIP_TOKEN(NIDa_keyword),    1},	// 58: <@keyword> ::= ifndef
{_reduce_42,	ZIP_TOKEN(NIDa_keyword),    1},	// 59: <@keyword> ::= include
{_reduce_43,	ZIP_TOKEN(NIDa_keyword),    1},	// 60: <@keyword> ::= left
{_reduce_44,	ZIP_TOKEN(NIDa_keyword),    1},	// 61: <@keyword> ::= lexid
{_reduce_45,	ZIP_TOKEN(NIDa_keyword),    1},	// 62: <@keyword> ::= prec
{_reduce_46,	ZIP_TOKEN(NIDa_keyword),    1} 	// 63: <@keyword> ::= right
};

struct C_ActionTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&) { return static_cast<uint8_t>(t1); }
    static uint8_t valueError() { return ACTION_ERROR; }
};

struct C_ShiftTraits
{
    template<class T1, class T2>
    static uint8_t map(T1 &&t1, T2 &&t2) { return static_cast<uint8_t>(t1+t2); }
    static uint8_t valueError() { RUNTIME_ERROR("SHIFT ERROR"); }
};

//
//   Generated Parser Policy
//
class C_ParserPolicy: public I_ParserPolicy
{
public:

    // Ctor
    C_ParserPolicy(): I_ParserPolicy(TOKENGEN_UB+2) {}

    // Implement I_ParserPolicy
    size_t action(bux::T_StateID state, bux::T_LexID token) const override;
    size_t getAcceptId() const override;
    bool getTokenName(bux::T_LexID token, std::string &name) const override;
    bux::T_StateID nextState(bux::T_StateID state, bux::T_LexID lex) const override;
    bool changeToken(bux::T_LexID &token, C_LexPtr &attr) const override;
    void getReduceInfo(size_t id, C_ReduceInfo &info) const override;
    void onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, std::string_view message) const override;
}   g_policy;

size_t C_ParserPolicy::action(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        return ACTION_ERROR;

    return index2value<uint8_t,uint8_t,int8_t,C_ActionTraits>(mapActionPtr[state], mapActionSizeEx[state], input);
}

size_t C_ParserPolicy::getAcceptId() const
{
    return 51;
}

bool C_ParserPolicy::getTokenName(bux::T_LexID token, std::string &name) const
{
    static constinit char const *const NAMES[38] = {
        "$Bracketed",
        "$Id",
        "$Key",
        "$LexSymbol",
        "$Nonterminal",
        "$Num",
        "$Operator",
        "$Spaces",
        "$String",
        "\"class\"",
        "\"else\"",
        "\"endif\"",
        "\"ifdef\"",
        "\"ifndef\"",
        "\"include\"",
        "\"left\"",
        "\"lexid\"",
        "\"prec\"",
        "\"right\"",
        "\"::\"",
        "\"::=\"",
        "<All>",
        "<AssocType>",
        "<InterBracketed>",
        "<Line>",
        "<NewLexIds>",
        "<OperatorAssociation>",
        "<OptionalTemplateArgs>",
        "<PreProcLine>",
        "<Production>",
        "<QualifiedName>",
        "<Semantics>",
        "<ShiftBase>",
        "<TemplateArg>",
        "<TemplateArgList>",
        "<Terminal>",
        "<@keyword>",
        "<@operator>"};
    if (bux::TOKENGEN_LB <= token && token < bux::TOKENGEN_LB + 38)
    {
        name = NAMES[token - bux::TOKENGEN_LB];
        return true;
    }
    return false;
}

bux::T_StateID C_ParserPolicy::nextState(bux::T_StateID state, bux::T_LexID input) const
{
    if (input >= bux::MIN_TOKEN_ID)
        input = ZIP_TOKEN(input);
    else if (input >= ENCODED_TOKEN_LB)
        LOGIC_ERROR("Invalid input: state={} input={}", (int)state, printToken(input));

    auto end = mapGoto + 25;
    auto found = std::lower_bound(mapGoto, end, state, [](const C_MapGoto &i, bux::T_StateID state_) {
        return i.m_curState < state_;
    });
    if (found != end && found->m_curState == state)
        return index2value<uint8_t,uint8_t,int8_t,C_ShiftTraits>(found->m_k2v, found->m_nextStateEx, input);

    RUNTIME_ERROR("Invalid state: state={} input={}", (int)state, printToken(input));
}

bool C_ParserPolicy::changeToken(T_LexID &token, C_LexPtr &attr) const
{
    // Grammar %UPCAST_TOKEN begins
    if (const auto it = int(token); isascii(it) && !iscntrl(it) && !isalnum(it) && !isspace(it))
    {
        attr.assign(bux::createLex<std::string>(1u,char(token)), true);
        token = TID_LEX_Operator;
        return true;
    }
    return false;
    // Grammar %UPCAST_TOKEN ends
}

void C_ParserPolicy::getReduceInfo(size_t id, C_ReduceInfo &info) const
{
    const auto &src  = prodInfo[id];
    info.m_ResultID  = src.m_ReducedID + (bux::MIN_TOKEN_ID-ENCODED_TOKEN_LB);
    info.m_PopLength = src.m_PopLength;
    info.m_Reduce    = src.m_pAction;
}

void C_ParserPolicy::onError(bux::LR1::C_Parser &_paRSeR_, const bux::C_SourcePos &pos, std::string_view message) const
{
    // Grammar %ON_ERROR begins
    dynamic_cast<Main::C_BNFParser&>(_paRSeR_).m_context.log(LL_ERROR, pos, message);
    // Grammar %ON_ERROR ends
}

} // namespace

namespace Main {

const bux::LR1::I_ParserPolicy &Main::C_BNFParser::policy() { return g_policy; }

} // namespace Main
