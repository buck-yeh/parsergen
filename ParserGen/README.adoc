:table-caption!:
:toc:
:toc-placement!:
:toclevels: 4 
//:toc-title: 
:source-highlighter: pygments
:source-language: c++
:pygments-style: colorful
:pygments-linenums-mode: inline
:icons: font
//:docinfo: private
:hide-uri-scheme:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

toc::[]

== Command line
.Output of `parsergen -h`
[source,bash]
----
USAGE: ./parsergen <Grammar> <Filename> <TokensOutput> [-I ARG] [-h]
DESCRIPTION:
  LR(1)/GLR-Parser Generator command line tool v1.6.1

  Where:
  1. <Grammar> is a grammar definition file.
  2. Generated C++ source files are named as:
     <Filename>IdDef.h - Lexical token enumerations
     <Filename>.h      - Header of parser class
     <Filename>.cpp    - Implementation of parser class
  3. Generated token definitions are written to <TokensOutput> to feed scannergen 

VALID FLAGS:
  -I, --include_dir ARG
	Search path of #include directive within <Grammar>
  -h, --help
	Display this help and exit
----

== Grammar
Grammar definition file consists of _lines_. There are 7 types of lines which can be mixed up _almost_ in no particular order. No line type is mandatory. The cases where line order does matter will be highlighted by ðŸ’£

=== 1. Empty line & Comment
Empty line together with

.https://en.wikipedia.org/wiki/Comment_(computer_programming)#C[C-style Comment]
[source,c]
----
/*
 *      Grammar with Semantic Rules
 */
----

.C++-style Comment
[source,c++]
----
// Grammar with Semantic Rules
----

All three above mean nothing else but enhancing readability. Put as many as you like where you like.

TIP: Comments can be used to disable other types of lines (and later re-enable them just as quickly): +
`//%SHOW_UNDEFINED`


=== 2. Production rule
.Syntax
> _<NonTerminal>_ ::= (_<NonTerminal>_|_<Terminal>_)* +
  _<NonTerminal>_ ::= (_<NonTerminal>_|_<Terminal>_)* [[ +
ã€€   Multi-lined reduction code in C++ +
]]

==== Example
[source,c++]
----
<All> ::= <Line>                        // <1>
<All> ::= <All> "\n" <Line>
<Line> ::= <Production> <Semantics> [[  // <2>
    auto &c = $c;
    if (!c.testCond())
        return;

    auto &prod = dynamic_cast<C_Production&>(*$1);
    if (!c.addProduction(prod, bux::tryUnlex<C_Semantic>($2))) [[unlikely]] // <3>
        $p.onError($1, "Production re-defined:\n"
                             "\t" + prod.str());
]]
----
<1> No [[ ]], no reduction.
<2> [[reduction_mnemonics]]Doubly-bracketed [[reduction code]] may contain the following mnemonics:
    - `$p` - Reference to the base parser class, _e.g._ of type `bux::LR1::C_Parser &`
    - `$P` - Reference to the generated parser class
    - `$c` - Reference to the context instance of the generated parser class if context type is defined by option `%CONTEXT`
    - `$r` - The result token buffer which can be freely assigned
    - `$1` `$2` `$3` ... denote the 1st, 2nd, 3rd, .. operand to the right of `::=` respectively, terminal or non-terminal.
<3> https://en.cppreference.com/w/cpp/language/attributes[C++ Attributes] can still be used in an reduction block 

==== Notes
. `parsergen` deals only context-free grammars. Therefore exactly one non-terminal is allowed to the left of ::= per production.
. A reduced non-terminal operand combines with zero or more terminal/ non-terminal neighbors, reduces again into 'upper' non-terminal, ... and eventually reduces into <@>, the root non-terminal _aka_ the https://en.wikipedia.org/wiki/Context-free_grammar#Formal_definitions[start symbol]. Thus the whole input string parsed is deemed _accepted_.  
. When there is no production rule at all, the grammar defined a language only accepting empty string, demonstrated by link:../example/MinLang/[MinLang]

CAUTION: ðŸ’£ `parsergen` has to know the start symbol before calculation. If there is a production like `<@> ::= ...`, then `<@>` is the start symbol. Otherwise, the left side of ::= in the *first parsed production*, say `<All>`, becomes the start symbol, and an extra production `<@> ::= <All>` is added implicitly.    

=== 3. % Option definition
.Syntax
> % $Id <Semantics>

.Example
[source,c++]
----
%HEADERS_FOR_HEADER [[
#include "BNFContext.h"     // C_BNFContext
]]
%CONTEXT            [[C_BNFContext]]
%SHOW_UNDEFINED 
----

==== Known Options
[%autowidth,cols="<.^m,^.^a,<.^a"]
|===
^.^h| Known Option ^.^h| Output To ^.^h| Action / Meaning

| %IDDEF_SOURCE | **Parser**_IdDef.h_ | Let "Path/To/IdDef.h" be value of `%IDDEF_SOURCE` +
Output
[source,c++]
#include "Path/To/IdDef.h"

| %ERROR_TOKEN | **Parser**_.cpp_ | If `%ERROR_TOKEN` is defined valuelessly or with value \[[Error]] and `$Error` is found in productions, the underlying *error recovery* mechanism of the base parser class will be enabled by telling `I_ParserPolicy` error token id is `TID_LEX_Error`, which will be defined in **Parser**_IdDef.h_ _(to be explained)_

| %UPCAST_TOKEN | **Parser**_.cpp_ | Implement the following policy method with valid mnemonics `$token` `$attr`
[source,c++]
bool C_ParserPolicy::changeToken(T_LexID &token, C_LexPtr &attr) const

A change to break down a scanned token input and take its first char as new input to resume parsing.

| %ON_ERROR | **Parser**_.cpp_ | Implement the following policy method with valid mnemonics link:#reduction_mnemonics[`$p` `$P` `$c`] `$pos` `$message`
[source,c++]
void C_ParserPolicy::onError(
     bux::LR1::C_Parser     &, 
     const bux::C_SourcePos &pos, 
     const std::string      &message) const

| %SHOW_UNDEFINED | **Parser**_.cpp_ +
**Parser**_.h_ +
*tokens.txt* | When defined, for every other known option _not defined_, say `%FOO`, and where output should be spared, output 
[source,c++]
----
 // %FOO undefined (expanded here otherwise)
----
Read all 3 output files of link:../example/MinLang/[MinLang] to find exact locations of such comment lines for various known options.

| %CONTEXT | **Parser**_.cpp_ +
**Parser**_.h_ | Type of public member data `m_context` of the generated parser class. This becomes necessary when user needs more tailored controls within code blocks either for reduction or defined by some of these known options thru mnemonic link:#reduction_mnemonics[`$c`] 

| %IGNORE_KEYWORD_CASE | **Parser**_IdDef.h_ +
*tokens.txt* | This option tells `parsergen` to treat keywords case-insensitively. Convenient when you define a case-insensitive language, e.g. `SQL`

//--------------------------
| %HEADERS_FOR_HEADER | **Parser**_.h_ | Output right _before_ where namespace scope of user's parser class begins:
[source,c++]
----
 // %HEADERS_FOR_HEADER expanded BEGIN
...(your code)...
 // %HEADERS_FOR_HEADER expanded END
----

| %PRECLASSDECL | **Parser**_.h_ | Output _within_ namespace scope of user's parser class and _before_ the class is defined:
[source,c++]
----
 // %PRECLASSDECL expanded BEGIN
...(your code)...
 // %PRECLASSDECL expanded END
----

| %INCLASSDECL | **Parser**_.h_ | Output _within_ the definition of user's parser class and right _after_ the common members are declared:
[source,c++]
----
 // %INCLASSDECL expanded BEGIN
...(your code)...
 // %INCLASSDECL expanded END
----

| %HEADERS_FOR_CPP | **Parser**_.cpp_ | Output _after_ the banner comment and _before_ any non-comment code:
[source,c++]
----
 // %HEADERS_FOR_CPP expanded BEGIN
...(your code)...
 // %HEADERS_FOR_CPP expanded END
----

| %LOCAL_CPP | **Parser**_.cpp_ | Output _within_ anonymous namespace scope and _between_ common `using namespace` declarations and in-module constant definitions:
[source,c++]
----
 // %LOCAL_CPP expanded BEGIN
...(your code)...
 // %LOCAL_CPP expanded END
----

| %SCOPED_CPP_HEAD | **Parser**_.cpp_ | Output _within_ namespace scope of user's parser class and _before_ ctor/method bodies of the class:
[source,c++]
----
 // %SCOPED_CPP_HEAD expanded BEGIN
...(your code)...
 // %SCOPED_CPP_HEAD expanded END
----

| %SCOPED_CPP_TAIL | **Parser**_.cpp_ | Output _within_ namespace scope of user's parser class and _after_ ctor/method bodies of the class:
[source,c++]
----
 // %SCOPED_CPP_TAIL expanded BEGIN
...(your code)...
 // %SCOPED_CPP_TAIL expanded END
----

| %SCANNEROPTION | *tokens.txt* | Output as the first part of *tokens.txt*
| %EXTRA_TOKENS | *tokens.txt* | \|-separated token identifiers which again \| with `parsergen`-genarated keywords & compound operators to for the final token definition for `scannergen`. The very last token is the mandated _initial state_ of the underlying https://en.wikipedia.org/wiki/Finite-state_machine[finite state machine]. +
 +
Multiple `%EXTRA_TOKENS` definitions are allowed. The result token will \|-concatenate all of them.
[source,c++]
----
%EXTRA_TOKENS   [[dec_num\|hex_num\|identifier\|c_char\|c_str\|spaces]]
%EXTRA_TOKENS   [[bracketed\|c_comment\|line_comment]]
%EXTRA_TOKENS   [[LexSymbol\|Nonterminal\|CompoundSymbol]]
----
.Output
_the_very_last_ = ...(generated keywords & compound operators)... \| dec_num\|hex_num\|identifier\|c_char\|c_str\|spaces\|bracketed\| ...(the rest)...

| HEADERS_FOR_SCANNER_CPP | *tokens.txt* | Output as _part of_ `%HEADERS_FOR_CPP` option value for `scannergen` like
[source,c++]
----
%HEADERS_FOR_CPP     [[
#include "ParserIdDef.h"

 // %HEADERS_FOR_SCANNER_CPP expanded BEGIN
#include "BracketBalance.h"
 // %HEADERS_FOR_SCANNER_CPP expanded END
using namespace Main;
]]
----

| %LOCALS_FOR_SCANNER_CPP | *tokens.txt* | Output as `%LOCAL_ACTION_DEFS` option value for `scannergen` like
[source,c++]
----
%LOCAL_ACTION_DEFS     [[
 // %LOCALS_FOR_SCANNER_CPP expanded BEGIN
#include "BracketBalance.h"
 // %LOCALS_FOR_SCANNER_CPP expanded END
]]
----

|===

=== 4. $ New lexid
_(To be explained)_

=== 5. # Directives
Seriously, these are not preprocessor directives but processed in the same pass as other type of lines. They just happen to use same old syntaxes:
[%autowidth,cols="2*<.^a"]
|===
^.^h| Directive ^.^h| Meaning
| [source%nowrap,c++]
#include "Foo" 
| Replace this line with lines within file _"Foo"_

| [source%nowrap,c++]
#ifdef _Bar_ 
| ðŸ’£ If option `%Bar` is defined, include subsequent lines until whichever the **paired** `#else` or `#endif` is reached first. Otherwise, include lines between `#else` and `#endif` if `#else` is present.

| [source%nowrap,c++]
#ifndef _Bar_ 
| ðŸ’£ If option `%Bar` is undefined, include subsequent lines until whichever the **paired** `#else` or `#endif` is reached first. Otherwise, include lines between `#else` and `#endif` if `#else` is present.

| [source,c++]
#else 
| ðŸ’£

| [source,c++]
#endif 
| ðŸ’£
|===

IMPORTANT: ðŸ’£ Pairing rules of `#ifdef`, `#ifndef`, `#else`, `#endif` comply with https://en.cppreference.com/w/cpp/preprocessor/conditional)[C++ preprocessor counterparts]

TIP: No `#if _(expr)_` and `#elif _(expr)_` because relevant scenarios are yet to be seen and the implementing effort is estimated high.

=== 6. Parser class naming
.Syntax
*class* (`<namespace>` ::)* `<class_name>`

.Example
*class* `Main::C_BNFParser`

.Notes
. At most one such line is allowed. 
. When absent, the parser class has the default name `::C_Parser`
. This will become a problem only when an application uses multiple `parsergen`-generated parsers.   
. Use of namespace(s) is encouraged when the generated parser is part of a library.

=== 7. Operator precedence
_(To be explained)_

== Generated files
_(To be explained)_